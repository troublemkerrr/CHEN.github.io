<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Claire&#39;s Space</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-12T14:10:12.707Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Claire</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMU15-445（FALL 2022）Project 2</title>
    <link href="http://example.com/2023/05/10/p2/"/>
    <id>http://example.com/2023/05/10/p2/</id>
    <published>2023-05-10T12:43:49.018Z</published>
    <updated>2023-05-12T14:10:12.707Z</updated>
    
    <content type="html"><![CDATA[<p>只记录自己在实现过程中遇到的问题，所以写得不够详尽（当然也不会公开完整代码</p><h2 id="B-树节点"><a href="#B-树节点" class="headerlink" title="B+树节点"></a>B+树节点</h2><p>b+树中有两种节点：内部节点（InternalPage）和叶子节点（LeafPage），这两种节点都继承自 BPlusTreePage。内部节点不保存记录，只用于索引，所有记录都保存在叶子节点中。这两种节点都不是直接创建的，而是由 BufferPool 管理的 Page 的 data部分强制转化而来。因此b+树节点的page_id_不仅是树中节点的编号，也是这个节点使用的 Page 在 BufferPool 中的编号。</p><p>两种节点都有这个成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MappingType std::pair<span class="meta-string">&lt;KeyType, ValueType&gt;</span></span></span><br><span class="line">MappingType array_[<span class="number">1</span>]; <span class="comment">// 柔性数组</span></span><br></pre></td></tr></table></figure><p>节点内的数据用array_来存储。数据都是键值对，InternalPage的键值对是 key — page_id（用于查找到子节点，可能是InternalPage或LeafPage），LeafPage的键值对是 key — RID（用于标识一个tuple，tuple对应数据库表中的一行数据）。</p><img src="https://s2.loli.net/2023/05/09/CGXjHlzTYsnAkvI.jpg" alt="array_示意图" style="zoom: 25%;" /><p>两种等效的使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*(array_ + idx) = &#123;key, value&#125;;</span><br><span class="line"></span><br><span class="line">array_[idx].first = key;</span><br><span class="line">array_[idx].second = value;</span><br></pre></td></tr></table></figure><p>这几种节点都不难实现，重点是要根据所需添加自定义成员方法。</p><p>浅谈<strong>部分新增的成员方法</strong>：</p><ul><li><p>Split：LeafPage 分裂时需要维护 next_page_id_，而 InternalPage 分裂时需要更改下方子节点的 parent_page_id_，Merge类似</p></li><li><p>为 InternalPage 写了两个插入方法，一个是插入到指定索引处，一个是先找到指定子节点的位置，然后插入在其后。会用到 std::move_backward() 方法</p></li><li><p>Remove：如果要删除中间的数据，就把后面的数据都往前移覆盖掉它；如果删除末尾的数据，直接把节点的大小-1即可。可以用 std::move() 或 std::copy() 帮助实现</p></li><li><p>查找key的索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意std::lower_bound()和std::distance()</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::KeyIndex</span><span class="params">(<span class="keyword">const</span> KeyType &amp;key, <span class="keyword">const</span> KeyComparator &amp;keyComparator)</span> <span class="keyword">const</span> -&gt; <span class="keyword">int</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> target = std::<span class="built_in">lower_bound</span>(array_, array_ + <span class="built_in">GetSize</span>(), key, [&amp;keyComparator](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair, <span class="keyword">auto</span> k) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">keyComparator</span>(pair.first, k) &lt; <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">distance</span>(array_, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="B-树数据结构"><a href="#B-树数据结构" class="headerlink" title="B+树数据结构"></a>B+树数据结构</h2><p><img src="https://s2.loli.net/2023/05/09/X7EwZBONlyScDrj.png" alt="b+树示例"></p><p>图中这颗b+树的 leaf_max_size_ = internal_max_size_ = 3。</p><p><strong>一些规则：</strong></p><ul><li><p>规定根节点的 parent_page_id_ 为 INVALID_PAGE_ID 。若树为空，root_page_id_ = INVALID_PAGE_ID。</p></li><li><p>KeyComparator 的比较规则是：左&lt;右时返回-1，左&gt;右时返回1，相等返回0。</p></li><li><p>叶子节点的min_size = leaf_max_size_ / 2，内部节点的min_size = (internal_max_size_ + 1) / 2。叶子节点在插入后判断是否满（所以叶子节点最多存 max_size_-1 的数据），内部节点在插入前判断，若满，则分裂。</p></li><li><p>若节点大小 &lt; min_size，需要合并或重新分配。</p></li><li><p>取一个页面，用 FetchPage，然后强转为B+树节点来使用；使用结束归还页面，用 UnpinPage；新建页面用 NewPage，删除页面用 DeletePage。new或者fetch页面之后，一定要记得unpin。</p></li></ul><h3 id="GetValue"><a href="#GetValue" class="headerlink" title="GetValue"></a>GetValue</h3><p>先用 GetLeafPage() 方法找到叶子节点，再在叶子节点中寻找值。GetLeafPage() 中用一个while循环，只要不是叶子节点就一直往下找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环内部如何确定走哪条路（确定下一个到达的子节点的page_id_</span></span><br><span class="line"><span class="keyword">page_id_t</span> next = cur_node_internal-&gt;<span class="built_in">ValueAt</span>(cur_node_internal-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);  <span class="comment">// 初始值是最后一个</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cur_node_internal-&gt;<span class="built_in">GetSize</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">comparator_</span>(cur_node_internal-&gt;<span class="built_in">KeyAt</span>(i), key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    next = cur_node_internal-&gt;<span class="built_in">ValueAt</span>(i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在叶子节点中寻找值的过程可以用二分法，我懒得写就直接遍历了。</p><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>如果是空树，就创建一个根节点。否则尝试向叶子节点中插入。如果叶子节点插入后满，则需要分裂叶子节点，并把分裂出的叶子节点的信息插入到上层内部节点中。如果上层内部节点也满了，就需要再分裂并向上插入，这是一个递归的过程。</p><p>注意向上插入过程中可能遇到不存在上层节点的情况，此时需要创建一个新的根节点，再插入。别忘了使用 UpdateRootPageId() 方法更新 root_page_id_，以及更新被插入子节点的 parent_page_id_。</p><p>内部节点是在插入前判断是否满，如果满了，分裂操作与叶子节点略有不同。需要先开辟一块较大内存，并强转为 InternalPage，然后把待分裂的内部节点拷贝到这块内存中，插入子节点后分裂，再把分裂后所剩的信息拷贝回原待分裂的内部节点，最后再将分裂出的节点向上插入并释放这块内存。代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> *mem = <span class="keyword">new</span> <span class="keyword">char</span>[INTERNAL_PAGE_HEADER_SIZE + <span class="built_in"><span class="keyword">sizeof</span></span>(MappingType) * (parent_node-&gt;<span class="built_in">GetSize</span>() + <span class="number">1</span>)];</span><br><span class="line"><span class="keyword">auto</span> *copy_parent_node = <span class="keyword">reinterpret_cast</span>&lt;InternalPage *&gt;(mem);</span><br><span class="line">std::<span class="built_in">memcpy</span>(mem, parent_page-&gt;<span class="built_in">GetData</span>(), INTERNAL_PAGE_HEADER_SIZE + <span class="built_in"><span class="keyword">sizeof</span></span>(MappingType) * (parent_node-&gt;<span class="built_in">GetSize</span>()));</span><br><span class="line">copy_parent_node-&gt;<span class="built_in">InsertNodeAfter</span>(old_node-&gt;<span class="built_in">GetPageId</span>(), key, new_node-&gt;<span class="built_in">GetPageId</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> parent_sibling_node = copy_parent_node-&gt;<span class="built_in">Split</span>(buffer_pool_manager_, comparator_, internal_max_size_);</span><br><span class="line">KeyType new_key = parent_sibling_node-&gt;<span class="built_in">KeyAt</span>(<span class="number">0</span>);</span><br><span class="line">std::<span class="built_in">memcpy</span>(parent_page-&gt;<span class="built_in">GetData</span>(), mem,</span><br><span class="line">          INTERNAL_PAGE_HEADER_SIZE + <span class="built_in"><span class="keyword">sizeof</span></span>(MappingType) * copy_parent_node-&gt;<span class="built_in">GetMinSize</span>());</span><br><span class="line"><span class="built_in">InsertIntoParent</span>(parent_node, new_key, parent_sibling_node, transaction);  <span class="comment">// 递归</span></span><br><span class="line">buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(parent_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);</span><br><span class="line">buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(parent_sibling_node-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">delete</span>[] mem;</span><br></pre></td></tr></table></figure><h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>删除后，如果节点足够大（&gt;= min_size），就不管。否则找到兄弟节点（要有同一个父节点，并且彼此相邻，先找左兄弟再找右兄弟），看兄弟节点是否够大（&gt; min_size），够大就借用一个，否则和兄弟节点合并。可能出现特殊情况：根节点是叶节点且大小为0，将树置为空；根节点是内部节点且大小为1，让其子节点作为新的根节点。</p><p>借用时，两种节点类似，只是InternalPage 会比 LeafPage 略复杂一些。下面只谈 InternalPage 的借用：</p><ul><li>如果兄弟节点在左边，父节点中对应自己的key要改成左兄弟的最后一个key。</li></ul><p><img src="https://s2.loli.net/2023/05/10/6HmadvKg3Q79GkE.png" alt="向左兄弟借用"></p><ul><li>如果兄弟节点在右边，将 父节点中对应右兄弟的key—右兄弟的value[0] 插入到自己的末尾，然后将父节点对应右兄弟的key改为右兄弟的key[1]，右兄弟删除第一个键值对。</li></ul><p><img src="https://s2.loli.net/2023/05/10/wpiAayxoDLB5NvH.png" alt="向右兄弟借用"></p><ul><li>注意借用的键值对下面的子节点要更改 parent_page_id_。</li></ul><p>合并时也是 InternalPage 略麻烦一些。将右节点合并到左节点时，第一个键值对是 父节点中对应右节点的key—右节点的value[0]。也别忘记更改下面子节点的 parent_page_id_。</p><p><strong>一些额外的小问题</strong>：</p><ol><li><p>page_header只在内存中有吗？在磁盘上只有page_data部分吗？</p><p>header在磁盘和内存中都有，在 BufferPool 的 page.data_ 部分，被强转为了内部页或者叶子页。</p><img src="https://s2.loli.net/2023/05/12/7RGiAjfKxZhv13P.png" alt="绿色部分是磁盘页，整个白色框内是内存页。Page metadata包括被pin次数、是否是脏页等" style="zoom: 50%;" /></li><li><p>InternalPage 和 LeafPage 的区别：</p><ul><li>header上：LeafPage 多一个字段 next_page_id_，所以叶子页header是28字节，而内部页是24字节。</li><li>data上：内部页第一个key-value中key无效，value有效。</li></ul></li><li><p>大多数数据库都使用唯一索引建立B+树，会增加一个隐式唯一ID。</p></li></ol><hr><h2 id="索引迭代器"><a href="#索引迭代器" class="headerlink" title="索引迭代器"></a>索引迭代器</h2><p>IndexIterator 类成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferPoolManager *buffer_pool_manager_;</span><br><span class="line">Page *page_;</span><br><span class="line">LeafPage *leaf_ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> index_ = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>几个要注意的点：</p><ul><li>析构时需要Unpin页面</li><li>*操作将取得array_中的一个键值对</li><li>对于++操作，如果此时迭代器指向的是当前页的最后一个键值对，需要先取到下一页并释放当前页</li><li><strong>End() 返回 INDEXITERATOR_TYPE(buffer_pool_manager_, page, cur_node-&gt;GetSize())</strong></li><li><strong>IsEnd() 判断 leaf_-&gt;GetNextPageId() == INVALID_PAGE_ID &amp;&amp; index_ == leaf_-&gt;GetSize()</strong></li></ul><hr><h2 id="并发索引"><a href="#并发索引" class="headerlink" title="并发索引"></a>并发索引</h2><p>可以先上一把大锁，跑一跑checkpoint2看看前面的实现有没有问题，都通过了再来写并发。</p><p>锁的粒度是页级，且是缓冲池的页，不是b+树节点的页。b+树节点的页是磁盘上存储的页，而缓冲池的页包含节点页，并且带有部分元数据信息。</p><p><strong>加锁的基本思想</strong>是： 1. 先锁住 parent page， 2. 再锁住 child page， 3. 如果 child page 是<em>安全</em>的，则释放 parent page 的锁。安全指当前 page 在当前操作下一定不会发生 Split / Redistribute / Coalesce。在 child page 不安全时，需要持续持有祖先的写锁。并在出现安全的 child page 后，释放所有祖先写锁。用 transaction 记录哪些 page 当前持有锁。</p><p>对于 Transaction 类，只需要关注下面几个成员变量和函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddIntoDeletedPageSet</span><span class="params">(<span class="keyword">page_id_t</span> page_id)</span> </span>&#123; deleted_page_set_-&gt;<span class="built_in">insert</span>(page_id); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddIntoPageSet</span><span class="params">(Page *page)</span> </span>&#123; page_set_-&gt;<span class="built_in">push_back</span>(page); &#125;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;std::unordered_set&lt;<span class="keyword">page_id_t</span>&gt;&gt; deleted_page_set_; <span class="comment">// 要删除的page</span></span><br><span class="line">std::shared_ptr&lt;std::deque&lt;Page *&gt;&gt; page_set_; <span class="comment">// 上锁的page</span></span><br></pre></td></tr></table></figure><p>对于 Page 类，需要关注：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Acquire the page write latch. */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WLatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">WLock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Release the page write latch. */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WUnlatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">WUnlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Acquire the page read latch. */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">RLatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">RLock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Release the page read latch. */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">RUnlatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">RUnlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Page latch. */</span></span><br><span class="line">ReaderWriterLatch rwlatch_;</span><br></pre></td></tr></table></figure><p>除了对 page 上锁，还需要对 root_page_id_ 单独上锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReaderWriterLatch root_page_id_latch_;</span><br></pre></td></tr></table></figure><p>下面简述<strong>部分上锁解锁流程</strong>：</p><ul><li><p>查找/插入/删除操作都需要先判断空树，所以<strong>给 root_page_id_ 上锁</strong>的任务放在函数开头。查找时加读锁；其余加写锁，并往 page_set_ 中加入一个nullptr，代表 root_page_id_ 上了锁。</p></li><li><p>根据key查找叶子节点时所用的 <strong>GetLeafPage()</strong> 方法，需要再传入一个参数 Operation（定义enum class Operation { SEARCH, INSERT, DELETE };），用来区分情况方便并发控制。SEARCH 时，直接解锁 root_page_id_ ，给根节点page加读锁，此后一直按加子锁、解父锁，Unpin父节点的流程进行，到最后只有叶子节点上了读锁。而  INSERT / DELETE 时，先给根节点加写锁，视情况（情况1）解锁 root_page_id_，此后一直按加子锁、将父节点 page_id_ 放入page_set_、视子节点情况（情况2）解开上面所有锁的流程进行，到最后只有不安全的节点被上锁，且除叶子节点的不安全节点都被放入page_set_。</p><p>情况1：INSERT 且不分裂，即 LeafPage大小 &lt; leaf_max_size_-1 或 InternalPage大小 &lt; internal_max_size_ / DELETE 且根节点大小&gt;2</p><p>情况2：INSERT 且不分裂 / DELETE 且不合并或重分配，即 节点大小 &gt; min_size_</p><p>解开上面所有锁的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BPLUSTREE_TYPE::ReleaseLatchFromQueue</span><span class="params">(Transaction *transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!transaction-&gt;<span class="built_in">GetPageSet</span>()-&gt;<span class="built_in">empty</span>()) &#123;  <span class="comment">// page_set_:the pages that were latched</span></span><br><span class="line">        Page *page = transaction-&gt;<span class="built_in">GetPageSet</span>()-&gt;<span class="built_in">front</span>();</span><br><span class="line">        transaction-&gt;<span class="built_in">GetPageSet</span>()-&gt;<span class="built_in">pop_front</span>(); <span class="comment">// 先解上面的锁</span></span><br><span class="line">        <span class="keyword">if</span> (page == <span class="literal">nullptr</span>) &#123;  <span class="comment">// page_set_中的nullptr代表root_page_id_latch_被加写锁</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;root_page_id_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">            buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DELETE 时如果要向兄弟节点借用或合并，需要<strong>给兄弟节点加写锁</strong>。</p></li><li><p>上了锁就<strong>别忘记解锁</strong>，通常是在函数return前 ReleaseLatchFromQueue(transaction)，并解开叶子节点的锁。</p></li><li><p>对于<strong>迭代器</strong>来说，需要在析构时解读锁，在++操作时也可能需要解锁加锁。</p></li></ul><hr><h2 id="🔮"><a href="#🔮" class="headerlink" title="🔮"></a>🔮</h2><img src="https://s2.loli.net/2023/05/12/C2nyZtEWRvmOVsu.png" style="zoom:50%;" /><p><img src="https://s2.loli.net/2023/05/12/Ic1PehTaqGDgBib.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;只记录自己在实现过程中遇到的问题，所以写得不够详尽（当然也不会公开完整代码&lt;/p&gt;
&lt;h2 id=&quot;B-树节点&quot;&gt;&lt;a href=&quot;#B-树节点&quot; class=&quot;headerlink&quot; title=&quot;B+树节点&quot;&gt;&lt;/a&gt;B+树节点&lt;/h2&gt;&lt;p&gt;b+树中有两种节点：内部节</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMU15-445（FALL 2022）Project 1</title>
    <link href="http://example.com/2023/05/09/p1/"/>
    <id>http://example.com/2023/05/09/p1/</id>
    <published>2023-05-09T07:58:54.777Z</published>
    <updated>2023-05-12T14:09:57.549Z</updated>
    
    <content type="html"><![CDATA[<p>只记录自己在实现过程中遇到的问题，所以写得不够详尽（当然也不会公开完整代码</p><h2 id="可扩展哈希表（extendible-hash-table）"><a href="#可扩展哈希表（extendible-hash-table）" class="headerlink" title="可扩展哈希表（extendible_hash_table）"></a>可扩展哈希表（extendible_hash_table）</h2><p>可扩展哈希表由ExtendibleHashTable类实现，成员变量有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_depth_;    <span class="comment">// 全局深度，全局深度=目录id的比特位数</span></span><br><span class="line"><span class="keyword">size_t</span> bucket_size_;  <span class="comment">// 桶的大小：桶最大容纳几个数据</span></span><br><span class="line"><span class="keyword">int</span> num_buckets_;     <span class="comment">// 哈希表中桶的数量</span></span><br><span class="line"><span class="keyword">mutable</span> std::mutex latch_;</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;Bucket&gt;&gt; dir_;  <span class="comment">// 目录：目录在指针中存储桶的地址，每个目录被分配一个id，目录扩张时id可能变化。目录数量=2^全局深度</span></span><br></pre></td></tr></table></figure><p>ExtendibleHashTable类中嵌套定义了Bucket类，即桶。Bucket类的成员变量有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> size_;  <span class="comment">// 桶的大小，就是ExtendibleHashTable中的bucket_size_</span></span><br><span class="line"><span class="keyword">int</span> depth_;    <span class="comment">// 局部深度</span></span><br><span class="line">std::list&lt;std::pair&lt;K, V&gt;&gt; list_; <span class="comment">// 所要存储的数据，是k-v对</span></span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2023/05/07/lGqIm7eC3p9LoAM.jpg" alt="可扩展哈希表图示" style="zoom: 33%;" /><p>对于查找/插入/删除操作，都会先映射到目录，再映射到桶。桶的数量是动态的，当桶中的元素超过bucket_size_时，桶会分裂成两个部分。当溢出桶的局部深度等于全局深度时，将发生目录扩容（2倍。</p><p><strong>初始时</strong>哈希表的global_depth_=0，num_buckets_=1，即有一个空桶。桶最初的depth_=0。</p><p>项目提供了IndexOf()方法，用于根据key得到目录id：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">auto</span> ExtendibleHashTable&lt;K, V&gt;::<span class="built_in">IndexOf</span>(<span class="keyword">const</span> K &amp;key) -&gt; <span class="keyword">size_t</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; global_depth_) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> std::hash&lt;K&gt;()(key) &amp; mask; <span class="comment">// key哈希后，末尾保留global_depth_比特位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">size_t</span> index = <span class="built_in">IndexOf</span>(key);</span><br><span class="line">std::shared_ptr&lt;Bucket&gt; bucket_ptr = dir_[index]; <span class="comment">// 拿到指向桶的指针</span></span><br></pre></td></tr></table></figure><p>现详述<strong>插入数据</strong>的过程：</p><p>先通过IndexOf()方法确定要把数据插入哪一个桶中，拿到这个桶。看list_.size()==size_是否为真来判断桶是否满，如果满了就需要先进行桶分裂再插入（但也有例外：如果桶里已经有这个key只需更新其value），否则直接插入数据。注意桶分裂可能发生多次（因为可能拆分桶时，所有数据流向了同一个桶），所以需要用while判断桶是否满了，而非使用if。在桶已满的前提下，如果该桶的局部深度等于全局深度，则需要进行目录扩容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录扩容</span></span><br><span class="line">global_depth_++;</span><br><span class="line"><span class="keyword">size_t</span> len = dir_.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  <span class="comment">// 为扩张的新目录分发桶</span></span><br><span class="line">dir_.<span class="built_in">emplace_back</span>(dir_[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现目录扩容后哈希表会变成这样：</p><img src="https://s2.loli.net/2023/05/07/fSogk6amwZGnxRu.jpg" alt="会有多个目录指针指向同一个桶" style="zoom:25%;" /><p>要把扩容的点指向共同的桶，比如01扩容到三位时变成0<strong>01</strong>和1<strong>01</strong>，两个目录需要同时指向原01的桶，因为在没有分裂之前，旧数据哈希后指向。</p><p>然后将这个待分裂桶的局部深度+1，拆分桶并重新分发目录指针和k-v对。别忘了拆分完后将桶的数量+1。拆分桶的实现细节如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; bucket_ptr-&gt;<span class="built_in">GetDepth</span>(); <span class="comment">// 此时局部深度还未+1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp;it : list) &#123;  <span class="comment">// list是待分裂桶的list_</span></span><br><span class="line">    <span class="keyword">size_t</span> hash_key = std::hash&lt;K&gt;()(it.first);</span><br><span class="line">    <span class="keyword">if</span> ((hash_key &amp; mask) != <span class="number">0U</span>) &#123;  <span class="comment">// 低位相同，只需要判断高位是0还是1</span></span><br><span class="line">    new_bucket0-&gt;<span class="built_in">Insert</span>(it.first, it.second); <span class="comment">// new_bucket0和new_bucket1会成为拆分后的两个桶的指针</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    new_bucket1-&gt;<span class="built_in">Insert</span>(it.first, it.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; dir_.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历目录，找出原桶指针的位置，用new_bucket0和new_bucket1代替</span></span><br><span class="line">    <span class="keyword">if</span> (dir_[i] == bucket_ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; mask) != <span class="number">0U</span>) &#123;  <span class="comment">// 判断高位是0还是1</span></span><br><span class="line">          dir_[i] = new_bucket0;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dir_[i] = new_bucket1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里画出一种可能的情况：</p><img src="https://s2.loli.net/2023/05/08/PO7pNGsButDwRHS.jpg" alt="此处mask=100（二进制" style="zoom:33%;" /><p>根据桶的局部深度得到mask，再用mask和数据的哈希值进行&amp;操作区分高位，从而把桶中数据分成两份，类似的，用mask和目录id相与，将新桶和目录匹配。</p><p>实际上哈希表的根本原理就是把数据哈希，用这个哈希值来将数据分类。最开始数据量少的时候不用分类，都放在一个桶里；然后数据多一些了，就看数据对应哈希值的最低位是0还是1，将数据分成两份即可；数据更多，就再看哈希值的第二低位……以此类推，逐渐细分数据，保证每个桶都没有溢出就好。</p><p><strong>并发控制</strong>就用一把大锁实现。在ExtendibleHashTable类中定义成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> std::mutex latch_;</span><br></pre></td></tr></table></figure><p>然后ExtendibleHashTable类成员函数开头上锁即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="LRU-K-淘汰策略"><a href="#LRU-K-淘汰策略" class="headerlink" title="LRU-K 淘汰策略"></a>LRU-K 淘汰策略</h2><p>不满k次FIFO，满k次LRU。优先从历史队列中淘汰。</p><img src="https://s2.loli.net/2023/05/08/WuJRm25OBZhoilr.png" style="zoom: 50%;" /><p>LRUKReplacer类中成员变量有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[[maybe_unused]] <span class="keyword">size_t</span> current_timestamp_&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> curr_size_&#123;<span class="number">0</span>&#125;; <span class="comment">// LRUKReplacer的大小，LRUKReplacer中可驱逐的缓存帧的数量，Size()方法返回这个</span></span><br><span class="line"><span class="keyword">size_t</span> replacer_size_; <span class="comment">// LRUKReplacer最多缓存多少帧</span></span><br><span class="line"><span class="keyword">size_t</span> k_;</span><br><span class="line">std::mutex latch_;</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;<span class="keyword">frame_id_t</span>, <span class="keyword">bool</span>&gt; is_evictable_; <span class="comment">// 标记是否可驱逐</span></span><br><span class="line"><span class="comment">// 不满k次，放在历史队列中</span></span><br><span class="line">std::list&lt;<span class="keyword">frame_id_t</span>&gt; history_frames_; <span class="comment">// 历史队列</span></span><br><span class="line">std::unordered_map&lt;<span class="keyword">frame_id_t</span>, std::list&lt;<span class="keyword">frame_id_t</span>&gt;::iterator&gt; history_pos_; <span class="comment">// 用于记录帧在队列中的位置，便于删除操作</span></span><br><span class="line">std::unordered_map&lt;<span class="keyword">frame_id_t</span>, <span class="keyword">size_t</span>&gt; history_times_; <span class="comment">// 记录访问次数</span></span><br><span class="line"><span class="comment">// 满k次，放在缓存队列中</span></span><br><span class="line">std::list&lt;<span class="keyword">frame_id_t</span>&gt; cache_frames_; <span class="comment">// 缓存队列</span></span><br><span class="line">std::unordered_map&lt;<span class="keyword">frame_id_t</span>, std::list&lt;<span class="keyword">frame_id_t</span>&gt;::iterator&gt; cache_pos_;</span><br></pre></td></tr></table></figure><p>要实现的方法：</p><ul><li><p>Evict(frame_id_t*)，驱逐一帧</p><p>驱逐后要标记为不可驱逐，从队列（当然也包括位置记录的map、访问次数记录的map）中删除，curr_size_–</p></li><li><p>RecordAccess(frame_id_t)，记录访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(frame_id &gt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(replacer_size_))&#123;  <span class="comment">// 注意类型转换</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果第一次访问：注意将帧标记为不可驱逐。然后把帧加到历史队列末尾，同时更新history_pos_：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history_pos_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(frame_id, --history_frames_.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure></li><li><p>SetEvictable(frame_id_t, bool set_evictable)，控制帧是否可驱逐，以及LRUKReplacer的大小</p><p>如果在is_evictable_里面没有记录或者set_evictable和is_evictable_里面的记录一致，就不管。否则将is_evictable_中的记录更新。再看该帧是否存在于LRUKReplacer中，若存在，再更改curr_size_的大小</p></li><li><p>Remove(frame_id_t)，清除访问记录</p><p>和Evict类似，只不过是指定了驱逐的帧。如果在is_evictable_里面没有记录，或是记录为false，或是不存在于LRUKReplacer中，直接返回。否则删除，并把is_evictable_中的记录置为false，curr_size_–</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history_frames_.<span class="built_in">erase</span>(history_pos_[frame_id]); <span class="comment">// 删除时根据history_pos_中的记录来删</span></span><br></pre></td></tr></table></figure></li><li><p>Size()</p><p>返回curr_size_</p></li></ul><p>个人觉得难点在于对curr_size_的把控。</p><p>并发控制还是一把大锁，和可扩展哈希一样。</p><hr><h2 id="缓冲池管理器（BufferPoolManagerInstance）"><a href="#缓冲池管理器（BufferPoolManagerInstance）" class="headerlink" title="缓冲池管理器（BufferPoolManagerInstance）"></a>缓冲池管理器（BufferPoolManagerInstance）</h2><p>一些基本概念：</p><ul><li><p>page_id 与 frame_id</p><p>磁盘被划分为若干块（页），每个块都用唯一的 page_id 来标识，disk_manager 就是根据 page_id 来读取和写入磁盘页。</p><p>磁盘页加载到内存，内存中也需要有相应的内存页（人为划分的内存页，也称为帧），BufferPoolManager 管理的正是这些内存块，和磁盘类似，内存页也有相应的标识 frame_id 来唯一标记这些内存页。</p></li><li><p>Pin 与 Unpin</p><p>Pin：把 frame_id 对应页面剔除 lru_list， 表示该页面被线程占用，不可以被置换出去。</p><p>Unpin：把 frame_id 对应的页面加入 lru_list，表示该页面可以被加入lru_replacer。</p></li><li><p>Page</p><p>系统中的所有内存页面都由 Page 对象表示。Page 对象主要由 metadata 和 data_[] 两部分构成，metedata 是一些元数据信息，如 page_id_, pin_count_、is_dirty_等，而 data_字符数组则是存储磁盘页的具体数据内容。 Page 对象是可以被重用的，即每个Page 对象都可以装入不同的磁盘页面。</p><p>pin_count_：用于记录当前内存页被占用的线程数量。NewPgImp 后 pin_count_ = 1, FetchPgImp 后pin_count_++, UnpinPg 后 pin_count_–-, pin_count_ 为 0 后可以逐出 LRUReplacer。</p><p>is_dirty_：用于记录当前内存页数据是否被修改（相对于磁盘数据）。</p></li></ul><p>再来看BufferPoolManagerInstance类的成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> pool_size_; <span class="comment">// 缓冲池能够管理的最大内存页数量，实际上就是pages_数组的大小</span></span><br><span class="line">std::atomic&lt;<span class="keyword">page_id_t</span>&gt; next_page_id_ = <span class="number">0</span>; <span class="comment">// 下一个将被分配的page_id，在创建新页时使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> bucket_size_ = <span class="number">4</span>; <span class="comment">// 可扩展哈希表中桶的大小</span></span><br><span class="line"></span><br><span class="line">Page *pages_; <span class="comment">// Page类型对象的数组，可将数组索引视为该页对应的frame_id</span></span><br><span class="line">DiskManager *disk_manager_ __attribute__((__unused__)); <span class="comment">// 磁盘管理器，用于执行与磁盘相关的底层操作，常用的有写入数据到磁盘WritePage和从磁盘读取数据ReadPage</span></span><br><span class="line">LogManager *log_manager_ __attribute__((__unused__));</span><br><span class="line">ExtendibleHashTable&lt;<span class="keyword">page_id_t</span>, <span class="keyword">frame_id_t</span>&gt; *page_table_; <span class="comment">// page_table_，用于页面映射</span></span><br><span class="line">LRUKReplacer *replacer_; <span class="comment">// replacer_,页面置换策略</span></span><br><span class="line">std::list&lt;<span class="keyword">frame_id_t</span>&gt; free_list_; <span class="comment">// 空闲内存页链表，刚实例化BPM时，所有的页面都应该加入free_list_, 此时LRUReplacer为空，没有可以置换的页面</span></span><br><span class="line">std::mutex latch_;</span><br></pre></td></tr></table></figure><p>要实现的方法：</p><ul><li><p>NewPgImp(page_id)：从磁盘创建一个新的物理页，然后在内存 BufferPool 找到一个位置放入。因为新申请的物理页没有有效的 data，所以 NewPgImp 不需要 ReadPage 操作，只需要完成元数据更新，ResetMemory 即可。优先使用free_list_中的空间，否则从replacer_中驱逐一页，腾出空间。放入 BufferPool 需要：将页面映射关系加入page_table_、放入replacer_、更新pages_数组中对应页面的信息。</p><p>注意replacer_中驱逐一页时需要先判断该页是否脏，若脏要写回磁盘。</p></li><li><p>FetchPgImp(page_id)：优先从 BufferPool 取 page_id 对应页面，如果不存在，则从磁盘调入（还是优先使用free_list_中的空间，否则从replacer_中驱逐一页，腾出空间），会把数据一起写入 BufferPool 内存页。</p></li><li><p>UnpinPgImp(page_id, is_dirty)：注意仅当 is_dirty 为真时才考虑改变 is_dirty_ 属性。</p></li><li><p>FlushPgImp(page_id) 与 FlushAllPagesImpl()：将页写回磁盘。</p></li><li><p>DeletePgImp(page_id)：如果 pin_count&gt;0，不能删除。注意将page_table_、replacer_、pages_数组中的有关信息一并清除，并把对应的frame_id 放回free_list_。</p></li></ul><p>一开始没有理解 BufferPool 的架构，苦恼了好一阵子。理解之后实现时多注意细节就好了。</p><p>并发控制：一把大锁。</p><hr><h2 id="🎈"><a href="#🎈" class="headerlink" title="🎈"></a>🎈</h2><img src="https://s2.loli.net/2023/05/09/KOoi1dn8PmGsTxk.png" style="zoom:50%;" /><p><img src="https://s2.loli.net/2023/05/09/mOgUWhGeEo5i3AJ.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;只记录自己在实现过程中遇到的问题，所以写得不够详尽（当然也不会公开完整代码&lt;/p&gt;
&lt;h2 id=&quot;可扩展哈希表（extendible-hash-table）&quot;&gt;&lt;a href=&quot;#可扩展哈希表（extendible-hash-table）&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMU15-445（FALL 2022）Project 0</title>
    <link href="http://example.com/2023/05/05/p0/"/>
    <id>http://example.com/2023/05/05/p0/</id>
    <published>2023-05-05T01:41:37.103Z</published>
    <updated>2023-05-12T14:09:46.398Z</updated>
    
    <content type="html"><![CDATA[<p>只记录自己在实现过程中遇到的问题，所以写得不够详尽（当然也不会公开完整代码</p><p>用时两个月紧赶慢赶地终于做完了p3。本来是打算等全部做完再开始写博客的，但是我突然有了一种很累想歇歇的感觉，所以干脆先写写博客、解决下之前遗留的问题，休息一阵子再研究p4吧。</p><h2 id="开始的开始——环境搭建"><a href="#开始的开始——环境搭建" class="headerlink" title="开始的开始——环境搭建"></a>开始的开始——环境搭建</h2><p>我的环境：Linux虚拟机（Ubuntu20.04.4）+ vscode远程连接，个人觉得挺舒服的</p><p>注意2022秋的代码仓库在这里：<a href="https://github.com/cmu-db/bustub/releases/tag/v20221128-2022fall">https://github.com/cmu-db/bustub/releases/tag/v20221128-2022fall</a> ，不要不小心把最新版本的拉下来</p><hr><h2 id="实现一颗字典树"><a href="#实现一颗字典树" class="headerlink" title="实现一颗字典树"></a>实现一颗字典树</h2><img src="https://s2.loli.net/2023/05/05/GZ4quAjsOytIQnE.jpg" alt="字典树图示" style="zoom: 25%;" /><p>图示是一颗字典树，其中共有5对键值对：(“ab”,1)，(“ac”,2)，(“bc”,3)，(“bcd”,4)，(“bef”,5)。因为不允许插入重复key，所以实际上一颗字典树里有几个TrieNodeWithValue就有几个key。</p><p><strong>如何遍历字典树？</strong>插入、删除和查找操作都离不开遍历。注意Trie类中的成员，根节点root_用一个unique_ptr来表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;TrieNode&gt; root_;</span><br></pre></td></tr></table></figure><p>遍历都从根节点开始。定义一个指向root_的unique_ptr，命名为cur，此后就利用cur来遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;TrieNode&gt; *cur = &amp;root_;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往下遍历一步，走到key_char_=key_char的节点上</span></span><br><span class="line">std::unique_ptr&lt;TrieNode&gt; *temp = (*cur)-&gt;<span class="built_in">GetChildNode</span>(key_char);</span><br><span class="line">cur = temp;</span><br></pre></td></tr></table></figure><p><strong>删除key时</strong>我也遇到一些小问题。就上图而言，如果想要删除(“bc”,3)，那么把(c-&gt;3)这个TrieNodeWithValue转换为TrieNode即可。如果想要删除(“bef”,5)，就需要把从(e)开始 包括自己及以下的所有节点用递归的方式删除。</p><p>如何判断删除时应该转换还是递归删除？看待删除key的下面还有没有路。比如”bc”下面还有(d-&gt;4)，有路，转换；”bef”下面没有路，递归删除。</p><p>如何递归删除？先判断起始节点begin_node，起始节点定义为遍历过程中遇到的倒数第二个TrieNodeWithValue，如果不存在就为root_。注意起始节点并不代表就要从这里一路删到底，只能说明在此之上没有需要删除的节点，从这里开始处理不会漏删。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Destory</span>(begin_node, key, i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归删除整棵树</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Destory</span><span class="params">(std::unique_ptr&lt;TrieNode&gt; *cur, <span class="keyword">const</span> std::string &amp;key, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="keyword">char</span>&gt;::size_type pos = i;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; key.<span class="built_in">size</span>() &amp;&amp; (*cur)-&gt;<span class="built_in">HasChild</span>(key[i])) &#123;</span><br><span class="line">      std::unique_ptr&lt;TrieNode&gt; *temp = (*cur)-&gt;<span class="built_in">GetChildNode</span>(key[i]);</span><br><span class="line">      flag = <span class="built_in">Destory</span>(temp, key, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      (*cur)-&gt;<span class="built_in">RemoveChildNode</span>(key[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*cur)-&gt;<span class="built_in">HasChildren</span>();  <span class="comment">// 如果有分支，就不再删除上面的部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>在Trie类中定义读写锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReaderWriterLatch latch_;</span><br></pre></td></tr></table></figure><p>对于插入和删除，上写锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">latch_.<span class="built_in">WLock</span>(); <span class="comment">// 函数开始时写这句</span></span><br><span class="line">latch_.<span class="built_in">WUnlock</span>(); <span class="comment">// 函数return前写这句</span></span><br></pre></td></tr></table></figure><p>对于查找只需要上读锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">latch_.<span class="built_in">RLock</span>();</span><br><span class="line">latch_.<span class="built_in">RUnlock</span>();</span><br></pre></td></tr></table></figure><hr><h2 id="记一些语法错误"><a href="#记一些语法错误" class="headerlink" title="记一些语法错误"></a>记一些语法错误</h2><p>我对c++的移动语义太不熟悉了，开始连编译都难过😢。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TrieNode</span>(TrieNode &amp;&amp;other_trie_node) <span class="keyword">noexcept</span> &#123; <span class="comment">// noexcept:告诉编译器，函数中不会发生异常</span></span><br><span class="line">    is_end_=other_trie_node.is_end_;</span><br><span class="line">    key_char_=other_trie_node.key_char_;</span><br><span class="line">    <span class="comment">// children_=other_trie_node.children_;❌ children_的类型嵌套了std::unique_ptr&lt;T&gt;，需要使用移动语义</span></span><br><span class="line">    children_=std::<span class="built_in">move</span>(other_trie_node.children_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert时到达最后一个节点，要把TrieNode转换成TrieNodeWithValue</span></span><br><span class="line"><span class="keyword">auto</span> new_node_ptr = <span class="keyword">new</span> TrieNodeWithValue&lt;T&gt;(std::<span class="built_in">move</span>(**cur), value);</span><br><span class="line">(*cur).<span class="built_in">reset</span>(new_node_ptr); <span class="comment">// 释放cur指向的资源对象，同时指向新的对象，用reset()</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TrieNodeWithValue(TrieNode &amp;&amp;trieNode, T value):TrieNode(trieNode) &#123;❌需要使用std::forward&lt;TrieNode&gt;转发右值引用</span></span><br><span class="line"><span class="built_in">TrieNodeWithValue</span>(TrieNode &amp;&amp;trieNode, T value):<span class="built_in">TrieNode</span>(std::forward&lt;TrieNode&gt;(trieNode)) &#123;</span><br><span class="line">    <span class="built_in">SetEndNode</span>(<span class="literal">true</span>);</span><br><span class="line">    value_=value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrieNode *last_node = (*cur).<span class="built_in">get</span>();  <span class="comment">// get()方法返回裸指针,不能用release() </span></span><br></pre></td></tr></table></figure><hr><h2 id="🎉"><a href="#🎉" class="headerlink" title="🎉"></a>🎉</h2><img src="https://s2.loli.net/2023/05/05/NIc3LoFU2A54vtX.png" alt="全部通过！" style="zoom: 50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;只记录自己在实现过程中遇到的问题，所以写得不够详尽（当然也不会公开完整代码&lt;/p&gt;
&lt;p&gt;用时两个月紧赶慢赶地终于做完了p3。本来是打算等全部做完再开始写博客的，但是我突然有了一种很累想歇歇的感觉，所以干脆先写写博客、解决下之前遗留的问题，休息一阵子再研究p4吧。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Claire&#39;s Art Show</title>
    <link href="http://example.com/2022/02/10/art/"/>
    <id>http://example.com/2022/02/10/art/</id>
    <published>2022-02-10T09:02:30.901Z</published>
    <updated>2023-05-12T13:12:57.833Z</updated>
    
    <content type="html"><![CDATA[<p>2021/12/13</p><img src="https://s2.loli.net/2022/01/21/EDl5TA94tbHnOvd.jpg" style="zoom:50%;" /><p>2022/01/28</p><img src="https://s2.loli.net/2022/02/10/wRh6UrIaTQ4ZFzt.jpg" style="zoom: 25%;" /><p>2022/02/07</p><img src="https://s2.loli.net/2022/02/10/D1fdQh2sCKjWIO7.jpg" style="zoom:25%;" /><p>2023/05/12</p><img src="https://s2.loli.net/2023/05/12/O9Bk8EDChZMXyoA.jpg" style="zoom:25%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2021/12/13&lt;/p&gt;
&lt;img src=&quot;https://s2.loli.net/2022/01/21/EDl5TA94tbHnOvd.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;2022/01/28&lt;/p&gt;
&lt;img src=&quot;https://s2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>learn to use typora</title>
    <link href="http://example.com/2022/01/17/learn%20to%20use%20typora/"/>
    <id>http://example.com/2022/01/17/learn%20to%20use%20typora/</id>
    <published>2022-01-17T11:55:34.810Z</published>
    <updated>2023-05-04T09:31:48.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><p>Ctrl+n :  n级标题</p><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h5 id="标题5"><a href="#标题5" class="headerlink" title="标题5"></a>标题5</h5><h6 id="标题6"><a href="#标题6" class="headerlink" title="标题6"></a>标题6</h6><p>正文</p><h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h3><p>引用 :  &gt; + 空格</p><p>退出引用 :  Shift + Tab</p><p>角标 :  </p><p>方括号里括^和数字</p><p>角标<a href="%E5%87%BA%E8%87%AA%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7">^1</a></p><blockquote><p>引用</p></blockquote><h3 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h3><p>无序列表 :  Ctrl + Shift + ]</p><p>子列表 :  Tab</p><p>回退 :  Shift + Tab</p><ul><li>列表</li><li>列表<ul><li>子列表<ul><li>子列表again</li></ul></li><li>回退到上一个子列表</li></ul></li><li>再回退</li></ul><p>有序列表 :  Ctrl + Shift +[</p><ol><li>列表</li><li>列表<ol><li>子列表</li></ol></li></ol><h3 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h3><p>[链接名称] + (地址)</p><p><a href="www.baidu.com">百度</a></p><h3 id="5-图像"><a href="#5-图像" class="headerlink" title="5.图像"></a>5.图像</h3><p><img src="https://s2.loli.net/2022/01/17/xb8MypS2BOLKavU.jpg"></p><h3 id="6-划重点"><a href="#6-划重点" class="headerlink" title="6.划重点"></a>6.划重点</h3><p>高亮 :   <img src="https://s2.loli.net/2022/01/17/IiqoHKBjLxzGdwb.png"></p><p>==高亮==</p><p>加粗 ：Ctrl + B</p><p><strong>加粗</strong></p><p>两个*中间夹斜体</p><p><em>斜体</em></p><h3 id="7-表格"><a href="#7-表格" class="headerlink" title="7.表格"></a>7.表格</h3><p>插入表格 ：Ctrl + T</p><table><thead><tr><th>chen</th><th></th><th></th></tr></thead><tbody><tr><td>zhang</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.代码块"></a>8.代码块</h3><p>输入3个*并按回车</p><hr><p>int c=1;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-标题&quot;&gt;&lt;a href=&quot;#1-标题&quot; class=&quot;headerlink&quot; title=&quot;1.标题&quot;&gt;&lt;/a&gt;1.标题&lt;/h3&gt;&lt;p&gt;Ctrl+n :  n级标题&lt;/p&gt;
&lt;h1 id=&quot;标题1&quot;&gt;&lt;a href=&quot;#标题1&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/11/23/hello-world/"/>
    <id>http://example.com/2021/11/23/hello-world/</id>
    <published>2021-11-23T00:27:48.068Z</published>
    <updated>2021-11-23T00:27:48.068Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
