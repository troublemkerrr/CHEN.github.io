<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Claire&#39;s Space</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-22T13:01:26.460Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Claire</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMU15-445（FALL 2022）Project 3</title>
    <link href="http://example.com/2023/05/22/p3/"/>
    <id>http://example.com/2023/05/22/p3/</id>
    <published>2023-05-22T12:54:47.002Z</published>
    <updated>2023-05-22T13:01:26.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bustub整体架构"><a href="#bustub整体架构" class="headerlink" title="bustub整体架构"></a>bustub整体架构</h2><img src="https://s2.loli.net/2023/05/14/DdMHLbn7afFrhUi.jpg" style="zoom:50%;" /><p><strong>Parser</strong>：负责接收SQL语句并将其转换为内部形式的表示，这个表示通常被称为”解析树”，它是一种抽象语法树（AST），代表了SQL查询的逻辑结构。</p><p>在解析器的工作过程中，还会进行语法和语义分析，包括检查SQL语句的正确性、验证表和字段是否存在、检查权限等。如果SQL语句中有语法错误或者非法操作，解析器会返回错误信息。</p><p><strong>Binder</strong>：将SQL语句中的参数值与解析树中的占位符（也称为绑定变量）进行绑定，生成Bustub AST。</p><p>Binder会对绑定变量和表达式进行类型检查，以确保它们在执行期间具有正确的数据类型，同时还会进行一些其他的优化，比如常量折叠、谓词下推等。</p><p><strong>Planner</strong>：负责根据Bustub AST生成初步的查询计划。查询计划也是一棵树的形式。</p><p><strong>Optimizer</strong>：用于确定执行给定数据库查询的最有效方式。优化器让未经优化的原始 plan 树依次经历多条规则，修改优化后得到最佳的执行计划。</p><p><strong>Query Execution</strong>：拿到 Optimizer 生成的具体的查询计划后，就要借助一系列算子进行数据查询了。算子也是 Project 3 中需要实现的主要内容。数据查询的步骤很简单，首先遍历查询计划树，将树上的 PlanNode 替换成对应的 Executor，然后按照 Top-to-Bottom 的方向执行算子即可。算子的执行模型采用火山模型：每个算子都有 Init() 和 Next() 两个方法。Init() 对算子进行初始化工作。Next() 则是向下层算子请求下一条数据。当 Next() 返回 false 时，则代表下层算子已经没有剩余数据，迭代结束。</p><hr><h2 id="访问方法执行器（Access-Method-Executors）"><a href="#访问方法执行器（Access-Method-Executors）" class="headerlink" title="访问方法执行器（Access Method Executors）"></a>访问方法执行器（Access Method Executors）</h2><h3 id="SeqScan（顺序扫描）"><a href="#SeqScan（顺序扫描）" class="headerlink" title="SeqScan（顺序扫描）"></a>SeqScan（顺序扫描）</h3><p>全表遍历，读取给定表中的所有 tuple，仅会出现在查询计划的叶子节点处。</p><p>具体实现时，主要是要关注两个输入参数：</p><ul><li><p>*<em>ExecutorContext <em>exec_ctx  执行器上下文</em></em></p><ul><li><p>GetBufferPoolManager() 缓冲池管理器    </p></li><li><p><strong>GetCatalog() 系统表</strong></p><p>Catalog类中方法：CreateTable()、GetTable()、CreateIndex()、GetIndex()、GetTableIndexes()、GetTableNames()</p></li><li><p><strong>GetTransaction() 事务</strong></p></li><li><p>GetLogManager() 日志管理器</p></li><li><p>GetLockManager() 锁管理器</p></li><li><p>GetTransactionManager() 事务管理器  </p></li></ul></li></ul><ul><li><p>*<em>SeqScanPlanNode <em>plan  顺序扫描执行节点</em></em></p><ul><li><p>GetType() 类型</p></li><li><p><strong>GetTableOid() 表的唯一ID</strong></p></li></ul></li></ul><p>同时看看这张表，能更清楚地认识 bustub 中的表结构：</p><img src="https://s2.loli.net/2023/05/15/GecwhDrlRotaTyB.png" alt="" style="zoom:50%;" /><p>全表遍历时需要知道表信息和迭代器位置，于是添加两个成员变量 table_info_ 和 table_iter_，并在 SeqScanExecutor 的构造方法或 Init() 方法中初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TableInfo *table_info_ = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>()-&gt;<span class="built_in">GetTable</span>(plan_-&gt;<span class="built_in">GetTableOid</span>());</span><br><span class="line">TableIterator table_iter_ = table_info_-&gt;table_-&gt;<span class="built_in">Begin</span>(exec_ctx_-&gt;<span class="built_in">GetTransaction</span>()); <span class="comment">// *后得到tuple</span></span><br></pre></td></tr></table></figure><p>后续就在每次调用 Next() 方法时将迭代器++即可，直至表的末尾。</p><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>还是拿到 table_info_，其中有个成员 std::unique_ptr&lt;TableHeap&gt; table_，需要使用 TableHeap 类的 InsertTuple() 方法来插入 tuple。用 while 循环每次拿到一个 child_executor 吐上来的 tuple 和 RID，插入表中并更新索引。更新索引代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义std::vector&lt;IndexInfo *&gt; table_idxs_，Init()中初始化</span></span><br><span class="line">table_idxs_ = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>()-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新索引</span></span><br><span class="line"><span class="keyword">if</span> (inserted) &#123; <span class="comment">// 如果成功插入，更新相关联的所有索引</span></span><br><span class="line">    <span class="keyword">for</span> (IndexInfo *index_info : table_idxs_) &#123;</span><br><span class="line">        index_info-&gt;index_-&gt;<span class="built_in">InsertEntry</span>(to_insert_tuple.<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, </span><br><span class="line">              index_info-&gt;key_schema_,index_info-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>()),</span><br><span class="line">                                        emit_rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    insert_count++; <span class="comment">// 统计插入数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 贴两个函数原型：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Insert an entry into the index.</span></span><br><span class="line"><span class="comment">* (Index类)</span></span><br><span class="line"><span class="comment">* 注意更新索引时，并不需要全部的tuple信息，而是需要经过转换后的tuple信息</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InsertEntry</span><span class="params">(<span class="keyword">const</span> Tuple &amp;key, RID rid, Transaction *transaction)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generates a key tuple given schemas and attributes (Tuple类)</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">KeyFromTuple</span><span class="params">(<span class="keyword">const</span> Schema &amp;schema, <span class="keyword">const</span> Schema &amp;key_schema, <span class="keyword">const</span> std::vector&lt;<span class="keyword">uint32_t</span>&gt; &amp;key_attrs)</span> -&gt; Tuple</span>;</span><br></pre></td></tr></table></figure><p>全部插入完成后，返回一个包含一个整数的 tuple，表示表中有多少行受到了影响。</p><p>注意 Next() 方法不只调用一次，所以需要设一个变量来标记是否插入完成。如果插入完成，Next() 方法就直接返回 false。</p><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>流程和 Insert 一样。</p><h3 id="IndexScan（索引扫描）"><a href="#IndexScan（索引扫描）" class="headerlink" title="IndexScan（索引扫描）"></a>IndexScan（索引扫描）</h3><p>用于 SELECT FROM &lt;table&gt; ORDER BY &lt;index column&gt;，ORDER BY 可以转化为 IndexScan。索引扫描需要按照索引的顺序输出表中所有 tuple。这里要用到的迭代器是 BPlusTreeIndexIteratorForOneIntegerColumn （实际上就是 Project 2 中实现的 B+树 IndexIterator）而非 TableIterator，去遍历叶子节点，拿到 RID 然后去表信息中查到对应的 tuple。</p><hr><h2 id="聚合和加入执行器（Aggregation-amp-Join-Executors）"><a href="#聚合和加入执行器（Aggregation-amp-Join-Executors）" class="headerlink" title="聚合和加入执行器（Aggregation &amp; Join Executors）"></a>聚合和加入执行器（Aggregation &amp; Join Executors）</h2><h3 id="Aggregation（聚合）"><a href="#Aggregation（聚合）" class="headerlink" title="Aggregation（聚合）"></a>Aggregation（聚合）</h3><p>此处的聚合实际上也包含了分组操作，用于SELECT colA, MIN(colB) FROM __mock_table_1 GROUP BY colA; 其中的 MIN() 和 GROUP BY 都用 AggregationExecutor 来实现。</p><p>在 AggregationExecutor 类中添加两个成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SimpleAggregationHashTable saht_; <span class="comment">// 包装后的哈希表：用于分组的key-根据这个key分组聚合后对应的结果，两者都是vecctor</span></span><br><span class="line">SimpleAggregationHashTable::Iterator saht_iterator_; <span class="comment">// 哈希表的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于SimpleAggregationHashTable，其成员变量有：</span></span><br><span class="line">    <span class="comment">// SimpleAggregationHashTable内部维护的哈希表 AggregateKey和AggregateValue都是vector</span></span><br><span class="line">    std::unordered_map&lt;AggregateKey, AggregateValue&gt; ht_&#123;&#125;;</span><br><span class="line">    <span class="comment">// 聚合表达式</span></span><br><span class="line">    <span class="keyword">const</span> std::vector&lt;AbstractExpressionRef&gt; &amp;agg_exprs_;</span><br><span class="line">    <span class="comment">// 聚合类型</span></span><br><span class="line">    <span class="keyword">const</span> std::vector&lt;AggregationType&gt; &amp;agg_types_;</span><br></pre></td></tr></table></figure><p>聚合操作全部在 <strong>Init()</strong> 中完成，将结果暂存在哈希表中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (child_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;</span><br><span class="line">    <span class="comment">// InsertCombine():如果没插入过这个key，就插入key与默认空值；然后在该key原有的聚合结果上做修改（无论是否第一次插入该key都要调用CombineAggregateValues()方法</span></span><br><span class="line">    <span class="comment">// MakeAggregateKey(&amp;tuple), MakeAggregateValue(&amp;tuple):将tuple的group_by字段和aggregate字段分别提取出来</span></span><br><span class="line">saht_.<span class="built_in">InsertCombine</span>(<span class="built_in">MakeAggregateKey</span>(&amp;tuple), <span class="built_in">MakeAggregateValue</span>(&amp;tuple)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意聚合时 count(*) 和 count(某一列) 存在区别，count(*) 相当于统计行数，不会忽略列值为空；而 count(某一列) 会忽略列值为空的情况。在聚合结果上做修改的函数 CombineAggregateValues() 正好体现了这一点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CombineAggregateValues</span><span class="params">(AggregateValue *result, <span class="keyword">const</span> AggregateValue &amp;input)</span> </span>&#123;  <span class="comment">// result：当前聚集结果，input：即将加入的新数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; agg_exprs_.<span class="built_in">size</span>(); i++) &#123;  <span class="comment">// 遍历</span></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (agg_types_[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> AggregationType::CountStarAggregate: <span class="comment">// 只有count(*)的默认空值是0，其余都是null</span></span><br><span class="line">                result-&gt;aggregates_[i] = result-&gt;aggregates_[i].<span class="built_in">Add</span>(ValueFactory::<span class="built_in">GetIntegerValue</span>(<span class="number">1</span>));  </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AggregationType::CountAggregate:</span><br><span class="line">                <span class="keyword">if</span> (result-&gt;aggregates_[i].<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">                result-&gt;aggregates_[i] = ValueFactory::<span class="built_in">GetIntegerValue</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!input.aggregates_[i].<span class="built_in">IsNull</span>()) &#123; <span class="comment">// 除了count(*)，都需要判断新加入的数据是否为空</span></span><br><span class="line">                result-&gt;aggregates_[i] = result-&gt;aggregates_[i].<span class="built_in">Add</span>(ValueFactory::<span class="built_in">GetIntegerValue</span>(<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AggregationType::SumAggregate:</span><br><span class="line">                ……</span><br><span class="line">            <span class="keyword">case</span> AggregationType::MinAggregate:</span><br><span class="line">                ……</span><br><span class="line">            <span class="keyword">case</span> AggregationType::MaxAggregate:</span><br><span class="line">                ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是在对空表执行聚合，需要单独处理。</p><p><strong>Next()</strong> 方法只需要返回聚合后的数据，每次获取一个哈希表中的键值对，直至到达哈希表末尾。返回的 tuple 格式为先放分组再放数据，即先放 AggregateKey，再放 AggregateValue。</p><h3 id="NestedLoopJoin（嵌套循环连接）"><a href="#NestedLoopJoin（嵌套循环连接）" class="headerlink" title="NestedLoopJoin（嵌套循环连接）"></a>NestedLoopJoin（嵌套循环连接）</h3><p>用 NestedLoopJoinExecutor 来实现内连接和左外连接查询，包括 WHERE、INNER JOIN、LEFT OUTER JOIN。左外连接会<br>查询出左表所有数据，以及两张表交集部分数据。</p><p>因为要实现内连接和左外连接，所以以左表为基准，每次比对左表的一个 tuple 和右表所有 tuple。如果比对成功，就将左右两表的 tuple 处理后通过Next() 方法返回。为了避免右表 tuple 在左表的第一次循环中被消耗完，我们需要在 Init() 方法中提前拿到右表所有的 tuple 并暂存。</p><p>存在这样一种可能：右表中有两条数据都和左表匹配，这时需要把两条数据都查询出来。所以每次拿到一个左表 tuple 时，一定要将它和右表所有 tuple 都比对一遍，不能在右表中找到一条对应的数据就不继续比对了。但是也不必在右表中找到一条对应的数据后，下一次又比对全部的右表数据，这样有太多重复的操作；比较好的做法是记录右表中上一次成功比对的位置，下一次就直接从这个位置开始比对。直到这个左表 tuple 完全比对完，再拿下一个左表 tuple。</p><p>如果左表tuple 没有和右表任何一个 tuple 匹配上，且是左外连接查询，则需要将该左表 tuple 和右表空值包装处理后返回，作为一条查询结果。</p><h3 id="NestedIndexJoin（嵌套索引连接）"><a href="#NestedIndexJoin（嵌套索引连接）" class="headerlink" title="NestedIndexJoin（嵌套索引连接）"></a>NestedIndexJoin（嵌套索引连接）</h3><p>NestIndexJoinExecutor 帮助实现了这类sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1(v1 <span class="type">int</span>, v2 <span class="type">int</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2(v3 <span class="type">int</span>, v4 <span class="type">int</span>);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX t2v3 <span class="keyword">on</span> t2(v3);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> v1 <span class="operator">=</span> v3;</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> PLANNER <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line">Projection &#123; exprs<span class="operator">=</span>[#<span class="number">0.0</span>, #<span class="number">0.1</span>, #<span class="number">0.2</span>, #<span class="number">0.3</span>] &#125; <span class="operator">|</span> (t1.v1:<span class="type">INTEGER</span>, t1.v2:<span class="type">INTEGER</span>, t2.v3:<span class="type">INTEGER</span>, t2.v4:<span class="type">INTEGER</span>)</span><br><span class="line">  NestedLoopJoin &#123; predicate<span class="operator">=</span>#<span class="number">0.0</span><span class="operator">=</span>#<span class="number">1.0</span> &#125; <span class="operator">|</span> (t1.v1:<span class="type">INTEGER</span>, t1.v2:<span class="type">INTEGER</span>, t2.v3:<span class="type">INTEGER</span>, t2.v4:<span class="type">INTEGER</span>)</span><br><span class="line">    SeqScan &#123; <span class="keyword">table</span><span class="operator">=</span>t1 &#125; <span class="operator">|</span> (t1.v1:<span class="type">INTEGER</span>, t1.v2:<span class="type">INTEGER</span>)</span><br><span class="line">    SeqScan &#123; <span class="keyword">table</span><span class="operator">=</span>t2 &#125; <span class="operator">|</span> (t2.v3:<span class="type">INTEGER</span>, t2.v4:<span class="type">INTEGER</span>)</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> OPTIMIZER <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span>   发现右表在列v3上有索引，把对右表的SeqScan和NestedLoopJoin优化为NestedIndexJoin（左表有无索引都可以，不影响</span><br><span class="line">NestedIndexJoin &#123; key_predicate<span class="operator">=</span>#<span class="number">0.0</span>, index<span class="operator">=</span>t2v3, index_table<span class="operator">=</span>t2 &#125;</span><br><span class="line">  SeqScan &#123; <span class="keyword">table</span><span class="operator">=</span>t1 &#125;</span><br></pre></td></tr></table></figure><p>其实实现起来与 NestedLoopJoinExecutor 类似。只是有两处区别，其一在于通过索引查找时，最多匹配一个结果；其二是尝试匹配右表 tuple 时的操作不同：拿 join key 去 B+Tree Index 里进行查询（具体实现会用到 project2 中的 GetValue() 方法），如果查询到结果，就拿着查到的 RID 去右表获取 tuple 然后装配成结果输出。</p><hr><h2 id="排序-限制执行器和-Top-N-优化（Sort-Limit-Executors-and-Top-N-Optimization）"><a href="#排序-限制执行器和-Top-N-优化（Sort-Limit-Executors-and-Top-N-Optimization）" class="headerlink" title="排序 + 限制执行器和 Top-N 优化（Sort + Limit Executors and Top-N Optimization）"></a>排序 + 限制执行器和 Top-N 优化（Sort + Limit Executors and Top-N Optimization）</h2><h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><p>与 AggregationExecutor 类似，都是在 Init() 中处理好全部数据，Next() 只负责返回结果。</p><p>排序的流程不难，先读取下层算子的所有 tuple，然后按 ORDER BY 的字段升序或降序排序即可。注意排序字段可能有多个，要按先后顺序比较。若第一个不相等，直接得到结果，否则继续比较第二个，按这样的规律进行下去。不会出现所有字段全部相等的情况。</p><h3 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h3><p>内部维护一个计数变量来实现。</p><h3 id="Top-N-优化规则"><a href="#Top-N-优化规则" class="headerlink" title="Top-N 优化规则"></a>Top-N 优化规则</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> __mock_table_1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> colA LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>基于之前的实现，这句 sql 会先对表中的所有数据进行排序，然后再截取前10个元素。这样做太低效，我们可以把排序和截取两个操作合并起来做，在内部维护一个优先级队列来跟踪前k个元素，以提高效率。这也就是 TopNExecutor 的实现思路。</p><p>除了实现 TopNExecutor，还要实现优化器 OptimizeSortLimitAsTopN，把 Sort + Limit 优化为 TopN。</p><p>优化器的工作原理实际上就是对 plan tree 进行后序遍历，自底向上地适用规则，改写节点。遍历到某个节点时，通过 if 语句来判断当前节点的类型是否符合优化的条件，若符合则进行优化。</p><p>能优化为一个 TopN 算子的形式是：上层节点为 Limit，下层节点为 Sort，不能反过来。因此，对 plan tree 进行后续遍历，在遇到 Limit 时，判断其下层节点是否为 Sort，若为 Sort，则将这两个节点替换为一个 TopN。</p><hr><h2 id="🎨"><a href="#🎨" class="headerlink" title="🎨"></a>🎨</h2><img src="https://s2.loli.net/2023/05/22/nZrz896cDvKEQhs.png" style="zoom: 50%;" /><p><img src="https://s2.loli.net/2023/05/22/TpsOC7e4ZXljVEG.png"></p><p>开始我还以为p3写得好呢，能排52，后面发现貌似是到52名都算作超时，不再往后排名了……应该是因为我没有写选做的 Leaderboard Task。先挖个坑在这里，日后来补。</p><p><img src="https://s2.loli.net/2023/05/22/fQTb8Jxia1KPdIX.png" alt="后面的都是52名"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;bustub整体架构&quot;&gt;&lt;a href=&quot;#bustub整体架构&quot; class=&quot;headerlink&quot; title=&quot;bustub整体架构&quot;&gt;&lt;/a&gt;bustub整体架构&lt;/h2&gt;&lt;img src=&quot;https://s2.loli.net/2023/05/14/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMU15-445（FALL 2022）Project 2</title>
    <link href="http://example.com/2023/05/10/p2/"/>
    <id>http://example.com/2023/05/10/p2/</id>
    <published>2023-05-10T12:43:49.018Z</published>
    <updated>2023-05-22T12:54:54.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B-树节点"><a href="#B-树节点" class="headerlink" title="B+树节点"></a>B+树节点</h2><p>b+树中有两种节点：内部节点（InternalPage）和叶子节点（LeafPage），这两种节点都继承自 BPlusTreePage。内部节点不保存记录，只用于索引，所有记录都保存在叶子节点中。这两种节点都不是直接创建的，而是由 BufferPool 管理的 Page 的 data部分强制转化而来。因此b+树节点的page_id_不仅是树中节点的编号，也是这个节点使用的 Page 在 BufferPool 中的编号。</p><p>两种节点都有这个成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MappingType std::pair<span class="meta-string">&lt;KeyType, ValueType&gt;</span></span></span><br><span class="line">MappingType array_[<span class="number">1</span>]; <span class="comment">// 柔性数组</span></span><br></pre></td></tr></table></figure><p>节点内的数据用array_来存储。数据都是键值对，InternalPage的键值对是 key — page_id（用于查找到子节点，可能是InternalPage或LeafPage），LeafPage的键值对是 key — RID（用于标识一个tuple，tuple对应数据库表中的一行数据）。</p><img src="https://s2.loli.net/2023/05/09/CGXjHlzTYsnAkvI.jpg" alt="array_示意图" style="zoom: 25%;" /><p>两种等效的使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*(array_ + idx) = &#123;key, value&#125;;</span><br><span class="line"></span><br><span class="line">array_[idx].first = key;</span><br><span class="line">array_[idx].second = value;</span><br></pre></td></tr></table></figure><p>这几种节点都不难实现，重点是要根据所需添加自定义成员方法。</p><p>浅谈<strong>部分新增的成员方法</strong>：</p><ul><li><p>Split：LeafPage 分裂时需要维护 next_page_id_，而 InternalPage 分裂时需要更改下方子节点的 parent_page_id_，Merge类似</p></li><li><p>为 InternalPage 写了两个插入方法，一个是插入到指定索引处，一个是先找到指定子节点的位置，然后插入在其后。会用到 std::move_backward() 方法</p></li><li><p>Remove：如果要删除中间的数据，就把后面的数据都往前移覆盖掉它；如果删除末尾的数据，直接把节点的大小-1即可。可以用 std::move() 或 std::copy() 帮助实现</p></li><li><p>查找key的索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意std::lower_bound()和std::distance()</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::KeyIndex</span><span class="params">(<span class="keyword">const</span> KeyType &amp;key, <span class="keyword">const</span> KeyComparator &amp;keyComparator)</span> <span class="keyword">const</span> -&gt; <span class="keyword">int</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> target = std::<span class="built_in">lower_bound</span>(array_, array_ + <span class="built_in">GetSize</span>(), key, [&amp;keyComparator](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair, <span class="keyword">auto</span> k) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">keyComparator</span>(pair.first, k) &lt; <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">distance</span>(array_, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="B-树数据结构"><a href="#B-树数据结构" class="headerlink" title="B+树数据结构"></a>B+树数据结构</h2><p><img src="https://s2.loli.net/2023/05/09/X7EwZBONlyScDrj.png" alt="b+树示例"></p><p>图中这颗b+树的 leaf_max_size_ = internal_max_size_ = 3。</p><p><strong>一些规则：</strong></p><ul><li><p>规定根节点的 parent_page_id_ 为 INVALID_PAGE_ID 。若树为空，root_page_id_ = INVALID_PAGE_ID。</p></li><li><p>KeyComparator 的比较规则是：左&lt;右时返回-1，左&gt;右时返回1，相等返回0。</p></li><li><p>叶子节点的min_size = leaf_max_size_ / 2，内部节点的min_size = (internal_max_size_ + 1) / 2。叶子节点在插入后判断是否满（所以叶子节点最多存 max_size_-1 的数据），内部节点在插入前判断，若满，则分裂。</p></li><li><p>若节点大小 &lt; min_size，需要合并或重新分配。</p></li><li><p>取一个页面，用 FetchPage，然后强转为B+树节点来使用；使用结束归还页面，用 UnpinPage；新建页面用 NewPage，删除页面用 DeletePage。new或者fetch页面之后，一定要记得unpin。</p></li></ul><h3 id="GetValue"><a href="#GetValue" class="headerlink" title="GetValue"></a>GetValue</h3><p>先用 GetLeafPage() 方法找到叶子节点，再在叶子节点中寻找值。GetLeafPage() 中用一个while循环，只要不是叶子节点就一直往下找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环内部如何确定走哪条路（确定下一个到达的子节点的page_id_</span></span><br><span class="line"><span class="keyword">page_id_t</span> next = cur_node_internal-&gt;<span class="built_in">ValueAt</span>(cur_node_internal-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);  <span class="comment">// 初始值是最后一个</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cur_node_internal-&gt;<span class="built_in">GetSize</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">comparator_</span>(cur_node_internal-&gt;<span class="built_in">KeyAt</span>(i), key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    next = cur_node_internal-&gt;<span class="built_in">ValueAt</span>(i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在叶子节点中寻找值的过程可以用二分法，我懒得写就直接遍历了。</p><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>如果是空树，就创建一个根节点。否则尝试向叶子节点中插入。如果叶子节点插入后满，则需要分裂叶子节点，并把分裂出的叶子节点的信息插入到上层内部节点中。如果上层内部节点也满了，就需要再分裂并向上插入，这是一个递归的过程。</p><p>注意向上插入过程中可能遇到不存在上层节点的情况，此时需要创建一个新的根节点，再插入。别忘了使用 UpdateRootPageId() 方法更新 root_page_id_，以及更新被插入子节点的 parent_page_id_。</p><p>内部节点是在插入前判断是否满，如果满了，分裂操作与叶子节点略有不同。需要先开辟一块较大内存，并强转为 InternalPage，然后把待分裂的内部节点拷贝到这块内存中，插入子节点后分裂，再把分裂后所剩的信息拷贝回原待分裂的内部节点，最后再将分裂出的节点向上插入并释放这块内存。代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> *mem = <span class="keyword">new</span> <span class="keyword">char</span>[INTERNAL_PAGE_HEADER_SIZE + <span class="built_in"><span class="keyword">sizeof</span></span>(MappingType) * (parent_node-&gt;<span class="built_in">GetSize</span>() + <span class="number">1</span>)];</span><br><span class="line"><span class="keyword">auto</span> *copy_parent_node = <span class="keyword">reinterpret_cast</span>&lt;InternalPage *&gt;(mem);</span><br><span class="line">std::<span class="built_in">memcpy</span>(mem, parent_page-&gt;<span class="built_in">GetData</span>(), INTERNAL_PAGE_HEADER_SIZE + <span class="built_in"><span class="keyword">sizeof</span></span>(MappingType) * (parent_node-&gt;<span class="built_in">GetSize</span>()));</span><br><span class="line">copy_parent_node-&gt;<span class="built_in">InsertNodeAfter</span>(old_node-&gt;<span class="built_in">GetPageId</span>(), key, new_node-&gt;<span class="built_in">GetPageId</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> parent_sibling_node = copy_parent_node-&gt;<span class="built_in">Split</span>(buffer_pool_manager_, comparator_, internal_max_size_);</span><br><span class="line">KeyType new_key = parent_sibling_node-&gt;<span class="built_in">KeyAt</span>(<span class="number">0</span>);</span><br><span class="line">std::<span class="built_in">memcpy</span>(parent_page-&gt;<span class="built_in">GetData</span>(), mem,</span><br><span class="line">          INTERNAL_PAGE_HEADER_SIZE + <span class="built_in"><span class="keyword">sizeof</span></span>(MappingType) * copy_parent_node-&gt;<span class="built_in">GetMinSize</span>());</span><br><span class="line"><span class="built_in">InsertIntoParent</span>(parent_node, new_key, parent_sibling_node, transaction);  <span class="comment">// 递归</span></span><br><span class="line">buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(parent_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);</span><br><span class="line">buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(parent_sibling_node-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">delete</span>[] mem;</span><br></pre></td></tr></table></figure><h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>删除后，如果节点足够大（&gt;= min_size），就不管。否则找到兄弟节点（要有同一个父节点，并且彼此相邻，先找左兄弟再找右兄弟），看兄弟节点是否够大（&gt; min_size），够大就借用一个，否则和兄弟节点合并。可能出现特殊情况：根节点是叶节点且大小为0，将树置为空；根节点是内部节点且大小为1，让其子节点作为新的根节点。</p><p>借用时，两种节点类似，只是InternalPage 会比 LeafPage 略复杂一些。下面只谈 InternalPage 的借用：</p><ul><li>如果兄弟节点在左边，父节点中对应自己的key要改成左兄弟的最后一个key。</li></ul><p><img src="https://s2.loli.net/2023/05/10/6HmadvKg3Q79GkE.png" alt="向左兄弟借用"></p><ul><li>如果兄弟节点在右边，将 父节点中对应右兄弟的key—右兄弟的value[0] 插入到自己的末尾，然后将父节点对应右兄弟的key改为右兄弟的key[1]，右兄弟删除第一个键值对。</li></ul><p><img src="https://s2.loli.net/2023/05/10/wpiAayxoDLB5NvH.png" alt="向右兄弟借用"></p><ul><li>注意借用的键值对下面的子节点要更改 parent_page_id_。</li></ul><p>合并时也是 InternalPage 略麻烦一些。将右节点合并到左节点时，第一个键值对是 父节点中对应右节点的key—右节点的value[0]。也别忘记更改下面子节点的 parent_page_id_。</p><p><strong>一些额外的小问题</strong>：</p><ol><li><p>page_header只在内存中有吗？在磁盘上只有page_data部分吗？</p><p>header在磁盘和内存中都有，在 BufferPool 的 page.data_ 部分，被强转为了内部页或者叶子页。</p><img src="https://s2.loli.net/2023/05/12/7RGiAjfKxZhv13P.png" alt="绿色部分是磁盘页，整个白色框内是内存页。Page metadata包括被pin次数、是否是脏页等" style="zoom: 50%;" /></li><li><p>InternalPage 和 LeafPage 的区别：</p><ul><li>header上：LeafPage 多一个字段 next_page_id_，所以叶子页header是28字节，而内部页是24字节。</li><li>data上：内部页第一个key-value中key无效，value有效。</li></ul></li><li><p>大多数数据库都使用唯一索引建立B+树，会增加一个隐式唯一ID。</p></li></ol><hr><h2 id="索引迭代器"><a href="#索引迭代器" class="headerlink" title="索引迭代器"></a>索引迭代器</h2><p>IndexIterator 类成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferPoolManager *buffer_pool_manager_;</span><br><span class="line">Page *page_;</span><br><span class="line">LeafPage *leaf_ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> index_ = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>几个要注意的点：</p><ul><li>析构时需要Unpin页面</li><li>*操作将取得array_中的一个键值对</li><li>对于++操作，如果此时迭代器指向的是当前页的最后一个键值对，需要先取到下一页并释放当前页</li><li><strong>End() 返回 INDEXITERATOR_TYPE(buffer_pool_manager_, page, cur_node-&gt;GetSize())</strong></li><li><strong>IsEnd() 判断 leaf_-&gt;GetNextPageId() == INVALID_PAGE_ID &amp;&amp; index_ == leaf_-&gt;GetSize()</strong></li></ul><hr><h2 id="并发索引"><a href="#并发索引" class="headerlink" title="并发索引"></a>并发索引</h2><p>可以先上一把大锁，跑一跑checkpoint2看看前面的实现有没有问题，都通过了再来写并发。</p><p>锁的粒度是页级，且是缓冲池的页，不是b+树节点的页。b+树节点的页是磁盘上存储的页，而缓冲池的页包含节点页，并且带有部分元数据信息。</p><p><strong>加锁的基本思想</strong>是： 1. 先锁住 parent page， 2. 再锁住 child page， 3. 如果 child page 是<em>安全</em>的，则释放 parent page 的锁。安全指当前 page 在当前操作下一定不会发生 Split / Redistribute / Coalesce。在 child page 不安全时，需要持续持有祖先的写锁。并在出现安全的 child page 后，释放所有祖先写锁。用 transaction 记录哪些 page 当前持有锁。</p><p>对于 Transaction 类，只需要关注下面几个成员变量和函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddIntoDeletedPageSet</span><span class="params">(<span class="keyword">page_id_t</span> page_id)</span> </span>&#123; deleted_page_set_-&gt;<span class="built_in">insert</span>(page_id); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddIntoPageSet</span><span class="params">(Page *page)</span> </span>&#123; page_set_-&gt;<span class="built_in">push_back</span>(page); &#125;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;std::unordered_set&lt;<span class="keyword">page_id_t</span>&gt;&gt; deleted_page_set_; <span class="comment">// 要删除的page</span></span><br><span class="line">std::shared_ptr&lt;std::deque&lt;Page *&gt;&gt; page_set_; <span class="comment">// 上锁的page</span></span><br></pre></td></tr></table></figure><p>对于 Page 类，需要关注：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Acquire the page write latch. */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WLatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">WLock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Release the page write latch. */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WUnlatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">WUnlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Acquire the page read latch. */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">RLatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">RLock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Release the page read latch. */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">RUnlatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">RUnlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Page latch. */</span></span><br><span class="line">ReaderWriterLatch rwlatch_;</span><br></pre></td></tr></table></figure><p>除了对 page 上锁，还需要对 root_page_id_ 单独上锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReaderWriterLatch root_page_id_latch_;</span><br></pre></td></tr></table></figure><p>下面简述<strong>部分上锁解锁流程</strong>：</p><ul><li><p>查找/插入/删除操作都需要先判断空树，所以<strong>给 root_page_id_ 上锁</strong>的任务放在函数开头。查找时加读锁；其余加写锁，并往 page_set_ 中加入一个nullptr，代表 root_page_id_ 上了锁。</p></li><li><p>根据key查找叶子节点时所用的 <strong>GetLeafPage()</strong> 方法，需要再传入一个参数 Operation（定义enum class Operation { SEARCH, INSERT, DELETE };），用来区分情况方便并发控制。SEARCH 时，直接解锁 root_page_id_ ，给根节点page加读锁，此后一直按加子锁、解父锁，Unpin父节点的流程进行，到最后只有叶子节点上了读锁。而  INSERT / DELETE 时，先给根节点加写锁，视情况（情况1）解锁 root_page_id_，此后一直按加子锁、将父节点 page_id_ 放入page_set_、视子节点情况（情况2）解开上面所有锁的流程进行，到最后只有不安全的节点被上锁，且除叶子节点的不安全节点都被放入page_set_。</p><p>情况1：INSERT 且不分裂，即 LeafPage大小 &lt; leaf_max_size_-1 或 InternalPage大小 &lt; internal_max_size_ / DELETE 且根节点大小&gt;2</p><p>情况2：INSERT 且不分裂 / DELETE 且不合并或重分配，即 节点大小 &gt; min_size_</p><p>解开上面所有锁的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BPLUSTREE_TYPE::ReleaseLatchFromQueue</span><span class="params">(Transaction *transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!transaction-&gt;<span class="built_in">GetPageSet</span>()-&gt;<span class="built_in">empty</span>()) &#123;  <span class="comment">// page_set_:the pages that were latched</span></span><br><span class="line">        Page *page = transaction-&gt;<span class="built_in">GetPageSet</span>()-&gt;<span class="built_in">front</span>();</span><br><span class="line">        transaction-&gt;<span class="built_in">GetPageSet</span>()-&gt;<span class="built_in">pop_front</span>(); <span class="comment">// 先解上面的锁</span></span><br><span class="line">        <span class="keyword">if</span> (page == <span class="literal">nullptr</span>) &#123;  <span class="comment">// page_set_中的nullptr代表root_page_id_latch_被加写锁</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;root_page_id_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">            buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DELETE 时如果要向兄弟节点借用或合并，需要<strong>给兄弟节点加写锁</strong>。</p></li><li><p>上了锁就<strong>别忘记解锁</strong>，通常是在函数return前 ReleaseLatchFromQueue(transaction)，并解开叶子节点的锁。</p></li><li><p>对于<strong>迭代器</strong>来说，需要在析构时解读锁，在++操作时也可能需要解锁加锁。</p></li></ul><hr><h2 id="🔮"><a href="#🔮" class="headerlink" title="🔮"></a>🔮</h2><img src="https://s2.loli.net/2023/05/12/C2nyZtEWRvmOVsu.png" style="zoom:50%;" /><p><img src="https://s2.loli.net/2023/05/15/3OdYsLMicDCxue2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;B-树节点&quot;&gt;&lt;a href=&quot;#B-树节点&quot; class=&quot;headerlink&quot; title=&quot;B+树节点&quot;&gt;&lt;/a&gt;B+树节点&lt;/h2&gt;&lt;p&gt;b+树中有两种节点：内部节点（InternalPage）和叶子节点（LeafPage），这两种节点都继承自 BPlu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMU15-445（FALL 2022）Project 1</title>
    <link href="http://example.com/2023/05/09/p1/"/>
    <id>http://example.com/2023/05/09/p1/</id>
    <published>2023-05-09T07:58:54.777Z</published>
    <updated>2023-05-22T12:55:06.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可扩展哈希表（extendible-hash-table）"><a href="#可扩展哈希表（extendible-hash-table）" class="headerlink" title="可扩展哈希表（extendible_hash_table）"></a>可扩展哈希表（extendible_hash_table）</h2><p>可扩展哈希表由ExtendibleHashTable类实现，成员变量有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_depth_;    <span class="comment">// 全局深度，全局深度=目录id的比特位数</span></span><br><span class="line"><span class="keyword">size_t</span> bucket_size_;  <span class="comment">// 桶的大小：桶最大容纳几个数据</span></span><br><span class="line"><span class="keyword">int</span> num_buckets_;     <span class="comment">// 哈希表中桶的数量</span></span><br><span class="line"><span class="keyword">mutable</span> std::mutex latch_;</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;Bucket&gt;&gt; dir_;  <span class="comment">// 目录：目录在指针中存储桶的地址，每个目录被分配一个id，目录扩张时id可能变化。目录数量=2^全局深度</span></span><br></pre></td></tr></table></figure><p>ExtendibleHashTable类中嵌套定义了Bucket类，即桶。Bucket类的成员变量有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> size_;  <span class="comment">// 桶的大小，就是ExtendibleHashTable中的bucket_size_</span></span><br><span class="line"><span class="keyword">int</span> depth_;    <span class="comment">// 局部深度</span></span><br><span class="line">std::list&lt;std::pair&lt;K, V&gt;&gt; list_; <span class="comment">// 所要存储的数据，是k-v对</span></span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2023/05/07/lGqIm7eC3p9LoAM.jpg" alt="可扩展哈希表图示" style="zoom: 33%;" /><p>对于查找/插入/删除操作，都会先映射到目录，再映射到桶。桶的数量是动态的，当桶中的元素超过bucket_size_时，桶会分裂成两个部分。当溢出桶的局部深度等于全局深度时，将发生目录扩容（2倍。</p><p><strong>初始时</strong>哈希表的global_depth_=0，num_buckets_=1，即有一个空桶。桶最初的depth_=0。</p><p>项目提供了IndexOf()方法，用于根据key得到目录id：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">auto</span> ExtendibleHashTable&lt;K, V&gt;::<span class="built_in">IndexOf</span>(<span class="keyword">const</span> K &amp;key) -&gt; <span class="keyword">size_t</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; global_depth_) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> std::hash&lt;K&gt;()(key) &amp; mask; <span class="comment">// key哈希后，末尾保留global_depth_比特位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">size_t</span> index = <span class="built_in">IndexOf</span>(key);</span><br><span class="line">std::shared_ptr&lt;Bucket&gt; bucket_ptr = dir_[index]; <span class="comment">// 拿到指向桶的指针</span></span><br></pre></td></tr></table></figure><p>现详述<strong>插入数据</strong>的过程：</p><p>先通过IndexOf()方法确定要把数据插入哪一个桶中，拿到这个桶。看list_.size()==size_是否为真来判断桶是否满，如果满了就需要先进行桶分裂再插入（但也有例外：如果桶里已经有这个key只需更新其value），否则直接插入数据。注意桶分裂可能发生多次（因为可能拆分桶时，所有数据流向了同一个桶），所以需要用while判断桶是否满了，而非使用if。在桶已满的前提下，如果该桶的局部深度等于全局深度，则需要进行目录扩容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录扩容</span></span><br><span class="line">global_depth_++;</span><br><span class="line"><span class="keyword">size_t</span> len = dir_.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  <span class="comment">// 为扩张的新目录分发桶</span></span><br><span class="line">dir_.<span class="built_in">emplace_back</span>(dir_[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现目录扩容后哈希表会变成这样：</p><img src="https://s2.loli.net/2023/05/07/fSogk6amwZGnxRu.jpg" alt="会有多个目录指针指向同一个桶" style="zoom:25%;" /><p>要把扩容的点指向共同的桶，比如01扩容到三位时变成0<strong>01</strong>和1<strong>01</strong>，两个目录需要同时指向原01的桶，因为在没有分裂之前，旧数据哈希后指向。</p><p>然后将这个待分裂桶的局部深度+1，拆分桶并重新分发目录指针和k-v对。别忘了拆分完后将桶的数量+1。拆分桶的实现细节如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; bucket_ptr-&gt;<span class="built_in">GetDepth</span>(); <span class="comment">// 此时局部深度还未+1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp;it : list) &#123;  <span class="comment">// list是待分裂桶的list_</span></span><br><span class="line">    <span class="keyword">size_t</span> hash_key = std::hash&lt;K&gt;()(it.first);</span><br><span class="line">    <span class="keyword">if</span> ((hash_key &amp; mask) != <span class="number">0U</span>) &#123;  <span class="comment">// 低位相同，只需要判断高位是0还是1</span></span><br><span class="line">    new_bucket0-&gt;<span class="built_in">Insert</span>(it.first, it.second); <span class="comment">// new_bucket0和new_bucket1会成为拆分后的两个桶的指针</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    new_bucket1-&gt;<span class="built_in">Insert</span>(it.first, it.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; dir_.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历目录，找出原桶指针的位置，用new_bucket0和new_bucket1代替</span></span><br><span class="line">    <span class="keyword">if</span> (dir_[i] == bucket_ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; mask) != <span class="number">0U</span>) &#123;  <span class="comment">// 判断高位是0还是1</span></span><br><span class="line">          dir_[i] = new_bucket0;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dir_[i] = new_bucket1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里画出一种可能的情况：</p><img src="https://s2.loli.net/2023/05/08/PO7pNGsButDwRHS.jpg" alt="此处mask=100（二进制" style="zoom:33%;" /><p>根据桶的局部深度得到mask，再用mask和数据的哈希值进行&amp;操作区分高位，从而把桶中数据分成两份，类似的，用mask和目录id相与，将新桶和目录匹配。</p><p>实际上哈希表的根本原理就是把数据哈希，用这个哈希值来将数据分类。最开始数据量少的时候不用分类，都放在一个桶里；然后数据多一些了，就看数据对应哈希值的最低位是0还是1，将数据分成两份即可；数据更多，就再看哈希值的第二低位……以此类推，逐渐细分数据，保证每个桶都没有溢出就好。</p><p><strong>并发控制</strong>就用一把大锁实现。在ExtendibleHashTable类中定义成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> std::mutex latch_;</span><br></pre></td></tr></table></figure><p>然后ExtendibleHashTable类成员函数开头上锁即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="LRU-K-淘汰策略"><a href="#LRU-K-淘汰策略" class="headerlink" title="LRU-K 淘汰策略"></a>LRU-K 淘汰策略</h2><p>不满k次FIFO，满k次LRU。优先从历史队列中淘汰。</p><img src="https://s2.loli.net/2023/05/08/WuJRm25OBZhoilr.png" style="zoom: 50%;" /><p>LRUKReplacer类中成员变量有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[[maybe_unused]] <span class="keyword">size_t</span> current_timestamp_&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> curr_size_&#123;<span class="number">0</span>&#125;; <span class="comment">// LRUKReplacer的大小，LRUKReplacer中可驱逐的缓存帧的数量，Size()方法返回这个</span></span><br><span class="line"><span class="keyword">size_t</span> replacer_size_; <span class="comment">// LRUKReplacer最多缓存多少帧</span></span><br><span class="line"><span class="keyword">size_t</span> k_;</span><br><span class="line">std::mutex latch_;</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;<span class="keyword">frame_id_t</span>, <span class="keyword">bool</span>&gt; is_evictable_; <span class="comment">// 标记是否可驱逐</span></span><br><span class="line"><span class="comment">// 不满k次，放在历史队列中</span></span><br><span class="line">std::list&lt;<span class="keyword">frame_id_t</span>&gt; history_frames_; <span class="comment">// 历史队列</span></span><br><span class="line">std::unordered_map&lt;<span class="keyword">frame_id_t</span>, std::list&lt;<span class="keyword">frame_id_t</span>&gt;::iterator&gt; history_pos_; <span class="comment">// 用于记录帧在队列中的位置，便于删除操作</span></span><br><span class="line">std::unordered_map&lt;<span class="keyword">frame_id_t</span>, <span class="keyword">size_t</span>&gt; history_times_; <span class="comment">// 记录访问次数</span></span><br><span class="line"><span class="comment">// 满k次，放在缓存队列中</span></span><br><span class="line">std::list&lt;<span class="keyword">frame_id_t</span>&gt; cache_frames_; <span class="comment">// 缓存队列</span></span><br><span class="line">std::unordered_map&lt;<span class="keyword">frame_id_t</span>, std::list&lt;<span class="keyword">frame_id_t</span>&gt;::iterator&gt; cache_pos_;</span><br></pre></td></tr></table></figure><p>要实现的方法：</p><ul><li><p>Evict(frame_id_t*)，驱逐一帧</p><p>驱逐后要标记为不可驱逐，从队列（当然也包括位置记录的map、访问次数记录的map）中删除，curr_size_–</p></li><li><p>RecordAccess(frame_id_t)，记录访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(frame_id &gt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(replacer_size_))&#123;  <span class="comment">// 注意类型转换</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果第一次访问：注意将帧标记为不可驱逐。然后把帧加到历史队列末尾，同时更新history_pos_：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history_pos_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(frame_id, --history_frames_.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure></li><li><p>SetEvictable(frame_id_t, bool set_evictable)，控制帧是否可驱逐，以及LRUKReplacer的大小</p><p>如果在is_evictable_里面没有记录或者set_evictable和is_evictable_里面的记录一致，就不管。否则将is_evictable_中的记录更新。再看该帧是否存在于LRUKReplacer中，若存在，再更改curr_size_的大小</p></li><li><p>Remove(frame_id_t)，清除访问记录</p><p>和Evict类似，只不过是指定了驱逐的帧。如果在is_evictable_里面没有记录，或是记录为false，或是不存在于LRUKReplacer中，直接返回。否则删除，并把is_evictable_中的记录置为false，curr_size_–</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history_frames_.<span class="built_in">erase</span>(history_pos_[frame_id]); <span class="comment">// 删除时根据history_pos_中的记录来删</span></span><br></pre></td></tr></table></figure></li><li><p>Size()</p><p>返回curr_size_</p></li></ul><p>个人觉得难点在于对curr_size_的把控。</p><p>并发控制还是一把大锁，和可扩展哈希一样。</p><hr><h2 id="缓冲池管理器（BufferPoolManagerInstance）"><a href="#缓冲池管理器（BufferPoolManagerInstance）" class="headerlink" title="缓冲池管理器（BufferPoolManagerInstance）"></a>缓冲池管理器（BufferPoolManagerInstance）</h2><p>一些基本概念：</p><ul><li><p>page_id 与 frame_id</p><p>磁盘被划分为若干块（页），每个块都用唯一的 page_id 来标识，disk_manager 就是根据 page_id 来读取和写入磁盘页。</p><p>磁盘页加载到内存，内存中也需要有相应的内存页（人为划分的内存页，也称为帧），BufferPoolManager 管理的正是这些内存块，和磁盘类似，内存页也有相应的标识 frame_id 来唯一标记这些内存页。</p></li><li><p>Pin 与 Unpin</p><p>Pin：把 frame_id 对应页面剔除 lru_list， 表示该页面被线程占用，不可以被置换出去。</p><p>Unpin：把 frame_id 对应的页面加入 lru_list，表示该页面可以被加入lru_replacer。</p></li><li><p>Page</p><p>系统中的所有内存页面都由 Page 对象表示。Page 对象主要由 metadata 和 data_[] 两部分构成，metedata 是一些元数据信息，如 page_id_, pin_count_、is_dirty_等，而 data_字符数组则是存储磁盘页的具体数据内容。 Page 对象是可以被重用的，即每个Page 对象都可以装入不同的磁盘页面。</p><p>pin_count_：用于记录当前内存页被占用的线程数量。NewPgImp 后 pin_count_ = 1, FetchPgImp 后pin_count_++, UnpinPg 后 pin_count_–-, pin_count_ 为 0 后可以逐出 LRUReplacer。</p><p>is_dirty_：用于记录当前内存页数据是否被修改（相对于磁盘数据）。</p></li></ul><p>再来看BufferPoolManagerInstance类的成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> pool_size_; <span class="comment">// 缓冲池能够管理的最大内存页数量，实际上就是pages_数组的大小</span></span><br><span class="line">std::atomic&lt;<span class="keyword">page_id_t</span>&gt; next_page_id_ = <span class="number">0</span>; <span class="comment">// 下一个将被分配的page_id，在创建新页时使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> bucket_size_ = <span class="number">4</span>; <span class="comment">// 可扩展哈希表中桶的大小</span></span><br><span class="line"></span><br><span class="line">Page *pages_; <span class="comment">// Page类型对象的数组，可将数组索引视为该页对应的frame_id</span></span><br><span class="line">DiskManager *disk_manager_ __attribute__((__unused__)); <span class="comment">// 磁盘管理器，用于执行与磁盘相关的底层操作，常用的有写入数据到磁盘WritePage和从磁盘读取数据ReadPage</span></span><br><span class="line">LogManager *log_manager_ __attribute__((__unused__));</span><br><span class="line">ExtendibleHashTable&lt;<span class="keyword">page_id_t</span>, <span class="keyword">frame_id_t</span>&gt; *page_table_; <span class="comment">// page_table_，用于页面映射</span></span><br><span class="line">LRUKReplacer *replacer_; <span class="comment">// replacer_,页面置换策略</span></span><br><span class="line">std::list&lt;<span class="keyword">frame_id_t</span>&gt; free_list_; <span class="comment">// 空闲内存页链表，刚实例化BPM时，所有的页面都应该加入free_list_, 此时LRUReplacer为空，没有可以置换的页面</span></span><br><span class="line">std::mutex latch_;</span><br></pre></td></tr></table></figure><p>要实现的方法：</p><ul><li><p>NewPgImp(page_id)：从磁盘创建一个新的物理页，然后在内存 BufferPool 找到一个位置放入。因为新申请的物理页没有有效的 data，所以 NewPgImp 不需要 ReadPage 操作，只需要完成元数据更新，ResetMemory 即可。优先使用free_list_中的空间，否则从replacer_中驱逐一页，腾出空间。放入 BufferPool 需要：将页面映射关系加入page_table_、放入replacer_、更新pages_数组中对应页面的信息。</p><p>注意replacer_中驱逐一页时需要先判断该页是否脏，若脏要写回磁盘。</p></li><li><p>FetchPgImp(page_id)：优先从 BufferPool 取 page_id 对应页面，如果不存在，则从磁盘调入（还是优先使用free_list_中的空间，否则从replacer_中驱逐一页，腾出空间），会把数据一起写入 BufferPool 内存页。</p></li><li><p>UnpinPgImp(page_id, is_dirty)：注意仅当 is_dirty 为真时才考虑改变 is_dirty_ 属性。</p></li><li><p>FlushPgImp(page_id) 与 FlushAllPagesImpl()：将页写回磁盘。</p></li><li><p>DeletePgImp(page_id)：如果 pin_count&gt;0，不能删除。注意将page_table_、replacer_、pages_数组中的有关信息一并清除，并把对应的frame_id 放回free_list_。</p></li></ul><p>一开始没有理解 BufferPool 的架构，苦恼了好一阵子。理解之后实现时多注意细节就好了。</p><p>并发控制：一把大锁。</p><hr><h2 id="🎈"><a href="#🎈" class="headerlink" title="🎈"></a>🎈</h2><img src="https://s2.loli.net/2023/05/09/KOoi1dn8PmGsTxk.png" style="zoom:50%;" /><p><img src="https://s2.loli.net/2023/05/09/mOgUWhGeEo5i3AJ.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;可扩展哈希表（extendible-hash-table）&quot;&gt;&lt;a href=&quot;#可扩展哈希表（extendible-hash-table）&quot; class=&quot;headerlink&quot; title=&quot;可扩展哈希表（extendible_hash_table）&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMU15-445（FALL 2022）Project 0</title>
    <link href="http://example.com/2023/05/05/p0/"/>
    <id>http://example.com/2023/05/05/p0/</id>
    <published>2023-05-05T01:41:37.103Z</published>
    <updated>2023-05-22T12:55:15.247Z</updated>
    
    <content type="html"><![CDATA[<p>用时两个月紧赶慢赶地终于做完了p3。本来是打算等全部做完再开始写博客的，但是我突然有了一种很累想歇歇的感觉，所以干脆先写写博客、解决下之前遗留的问题，休息一阵子再研究p4吧。</p><h2 id="开始的开始——环境搭建"><a href="#开始的开始——环境搭建" class="headerlink" title="开始的开始——环境搭建"></a>开始的开始——环境搭建</h2><p>我的环境：Linux虚拟机（Ubuntu20.04.4）+ vscode远程连接，个人觉得挺舒服的</p><p>注意2022秋的代码仓库在这里：<a href="https://github.com/cmu-db/bustub/releases/tag/v20221128-2022fall">https://github.com/cmu-db/bustub/releases/tag/v20221128-2022fall</a> ，不要不小心把最新版本的拉下来</p><hr><h2 id="实现一颗字典树"><a href="#实现一颗字典树" class="headerlink" title="实现一颗字典树"></a>实现一颗字典树</h2><img src="https://s2.loli.net/2023/05/05/GZ4quAjsOytIQnE.jpg" alt="字典树图示" style="zoom: 25%;" /><p>图示是一颗字典树，其中共有5对键值对：(“ab”,1)，(“ac”,2)，(“bc”,3)，(“bcd”,4)，(“bef”,5)。因为不允许插入重复key，所以实际上一颗字典树里有几个TrieNodeWithValue就有几个key。</p><p><strong>如何遍历字典树？</strong>插入、删除和查找操作都离不开遍历。注意Trie类中的成员，根节点root_用一个unique_ptr来表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;TrieNode&gt; root_;</span><br></pre></td></tr></table></figure><p>遍历都从根节点开始。定义一个指向root_的unique_ptr，命名为cur，此后就利用cur来遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;TrieNode&gt; *cur = &amp;root_;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往下遍历一步，走到key_char_=key_char的节点上</span></span><br><span class="line">std::unique_ptr&lt;TrieNode&gt; *temp = (*cur)-&gt;<span class="built_in">GetChildNode</span>(key_char);</span><br><span class="line">cur = temp;</span><br></pre></td></tr></table></figure><p><strong>删除key时</strong>我也遇到一些小问题。就上图而言，如果想要删除(“bc”,3)，那么把(c-&gt;3)这个TrieNodeWithValue转换为TrieNode即可。如果想要删除(“bef”,5)，就需要把从(e)开始 包括自己及以下的所有节点用递归的方式删除。</p><p>如何判断删除时应该转换还是递归删除？看待删除key的下面还有没有路。比如”bc”下面还有(d-&gt;4)，有路，转换；”bef”下面没有路，递归删除。</p><p>如何递归删除？先判断起始节点begin_node，起始节点定义为遍历过程中遇到的倒数第二个TrieNodeWithValue，如果不存在就为root_。注意起始节点并不代表就要从这里一路删到底，只能说明在此之上没有需要删除的节点，从这里开始处理不会漏删。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Destory</span>(begin_node, key, i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归删除整棵树</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Destory</span><span class="params">(std::unique_ptr&lt;TrieNode&gt; *cur, <span class="keyword">const</span> std::string &amp;key, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="keyword">char</span>&gt;::size_type pos = i;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; key.<span class="built_in">size</span>() &amp;&amp; (*cur)-&gt;<span class="built_in">HasChild</span>(key[i])) &#123;</span><br><span class="line">      std::unique_ptr&lt;TrieNode&gt; *temp = (*cur)-&gt;<span class="built_in">GetChildNode</span>(key[i]);</span><br><span class="line">      flag = <span class="built_in">Destory</span>(temp, key, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      (*cur)-&gt;<span class="built_in">RemoveChildNode</span>(key[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*cur)-&gt;<span class="built_in">HasChildren</span>();  <span class="comment">// 如果有分支，就不再删除上面的部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>在Trie类中定义读写锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReaderWriterLatch latch_;</span><br></pre></td></tr></table></figure><p>对于插入和删除，上写锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">latch_.<span class="built_in">WLock</span>(); <span class="comment">// 函数开始时写这句</span></span><br><span class="line">latch_.<span class="built_in">WUnlock</span>(); <span class="comment">// 函数return前写这句</span></span><br></pre></td></tr></table></figure><p>对于查找只需要上读锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">latch_.<span class="built_in">RLock</span>();</span><br><span class="line">latch_.<span class="built_in">RUnlock</span>();</span><br></pre></td></tr></table></figure><hr><h2 id="记一些语法错误"><a href="#记一些语法错误" class="headerlink" title="记一些语法错误"></a>记一些语法错误</h2><p>我对c++的移动语义太不熟悉了，开始连编译都难过😢。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TrieNode</span>(TrieNode &amp;&amp;other_trie_node) <span class="keyword">noexcept</span> &#123; <span class="comment">// noexcept:告诉编译器，函数中不会发生异常</span></span><br><span class="line">    is_end_=other_trie_node.is_end_;</span><br><span class="line">    key_char_=other_trie_node.key_char_;</span><br><span class="line">    <span class="comment">// children_=other_trie_node.children_;❌ children_的类型嵌套了std::unique_ptr&lt;T&gt;，需要使用移动语义</span></span><br><span class="line">    children_=std::<span class="built_in">move</span>(other_trie_node.children_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert时到达最后一个节点，要把TrieNode转换成TrieNodeWithValue</span></span><br><span class="line"><span class="keyword">auto</span> new_node_ptr = <span class="keyword">new</span> TrieNodeWithValue&lt;T&gt;(std::<span class="built_in">move</span>(**cur), value);</span><br><span class="line">(*cur).<span class="built_in">reset</span>(new_node_ptr); <span class="comment">// 释放cur指向的资源对象，同时指向新的对象，用reset()</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TrieNodeWithValue(TrieNode &amp;&amp;trieNode, T value):TrieNode(trieNode) &#123;❌需要使用std::forward&lt;TrieNode&gt;转发右值引用</span></span><br><span class="line"><span class="built_in">TrieNodeWithValue</span>(TrieNode &amp;&amp;trieNode, T value):<span class="built_in">TrieNode</span>(std::forward&lt;TrieNode&gt;(trieNode)) &#123;</span><br><span class="line">    <span class="built_in">SetEndNode</span>(<span class="literal">true</span>);</span><br><span class="line">    value_=value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrieNode *last_node = (*cur).<span class="built_in">get</span>();  <span class="comment">// get()方法返回裸指针,不能用release() </span></span><br></pre></td></tr></table></figure><hr><h2 id="🎉"><a href="#🎉" class="headerlink" title="🎉"></a>🎉</h2><img src="https://s2.loli.net/2023/05/05/NIc3LoFU2A54vtX.png" alt="全部通过！" style="zoom: 50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用时两个月紧赶慢赶地终于做完了p3。本来是打算等全部做完再开始写博客的，但是我突然有了一种很累想歇歇的感觉，所以干脆先写写博客、解决下之前遗留的问题，休息一阵子再研究p4吧。&lt;/p&gt;
&lt;h2 id=&quot;开始的开始——环境搭建&quot;&gt;&lt;a href=&quot;#开始的开始——环境搭建&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Claire&#39;s Art Show</title>
    <link href="http://example.com/2022/02/10/art/"/>
    <id>http://example.com/2022/02/10/art/</id>
    <published>2022-02-10T09:02:30.901Z</published>
    <updated>2023-05-12T13:12:57.833Z</updated>
    
    <content type="html"><![CDATA[<p>2021/12/13</p><img src="https://s2.loli.net/2022/01/21/EDl5TA94tbHnOvd.jpg" style="zoom:50%;" /><p>2022/01/28</p><img src="https://s2.loli.net/2022/02/10/wRh6UrIaTQ4ZFzt.jpg" style="zoom: 25%;" /><p>2022/02/07</p><img src="https://s2.loli.net/2022/02/10/D1fdQh2sCKjWIO7.jpg" style="zoom:25%;" /><p>2023/05/12</p><img src="https://s2.loli.net/2023/05/12/O9Bk8EDChZMXyoA.jpg" style="zoom:25%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2021/12/13&lt;/p&gt;
&lt;img src=&quot;https://s2.loli.net/2022/01/21/EDl5TA94tbHnOvd.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;2022/01/28&lt;/p&gt;
&lt;img src=&quot;https://s2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>learn to use typora</title>
    <link href="http://example.com/2022/01/17/learn%20to%20use%20typora/"/>
    <id>http://example.com/2022/01/17/learn%20to%20use%20typora/</id>
    <published>2022-01-17T11:55:34.810Z</published>
    <updated>2023-05-04T09:31:48.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><p>Ctrl+n :  n级标题</p><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h5 id="标题5"><a href="#标题5" class="headerlink" title="标题5"></a>标题5</h5><h6 id="标题6"><a href="#标题6" class="headerlink" title="标题6"></a>标题6</h6><p>正文</p><h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h3><p>引用 :  &gt; + 空格</p><p>退出引用 :  Shift + Tab</p><p>角标 :  </p><p>方括号里括^和数字</p><p>角标<a href="%E5%87%BA%E8%87%AA%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7">^1</a></p><blockquote><p>引用</p></blockquote><h3 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h3><p>无序列表 :  Ctrl + Shift + ]</p><p>子列表 :  Tab</p><p>回退 :  Shift + Tab</p><ul><li>列表</li><li>列表<ul><li>子列表<ul><li>子列表again</li></ul></li><li>回退到上一个子列表</li></ul></li><li>再回退</li></ul><p>有序列表 :  Ctrl + Shift +[</p><ol><li>列表</li><li>列表<ol><li>子列表</li></ol></li></ol><h3 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h3><p>[链接名称] + (地址)</p><p><a href="www.baidu.com">百度</a></p><h3 id="5-图像"><a href="#5-图像" class="headerlink" title="5.图像"></a>5.图像</h3><p><img src="https://s2.loli.net/2022/01/17/xb8MypS2BOLKavU.jpg"></p><h3 id="6-划重点"><a href="#6-划重点" class="headerlink" title="6.划重点"></a>6.划重点</h3><p>高亮 :   <img src="https://s2.loli.net/2022/01/17/IiqoHKBjLxzGdwb.png"></p><p>==高亮==</p><p>加粗 ：Ctrl + B</p><p><strong>加粗</strong></p><p>两个*中间夹斜体</p><p><em>斜体</em></p><h3 id="7-表格"><a href="#7-表格" class="headerlink" title="7.表格"></a>7.表格</h3><p>插入表格 ：Ctrl + T</p><table><thead><tr><th>chen</th><th></th><th></th></tr></thead><tbody><tr><td>zhang</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.代码块"></a>8.代码块</h3><p>输入3个*并按回车</p><hr><p>int c=1;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-标题&quot;&gt;&lt;a href=&quot;#1-标题&quot; class=&quot;headerlink&quot; title=&quot;1.标题&quot;&gt;&lt;/a&gt;1.标题&lt;/h3&gt;&lt;p&gt;Ctrl+n :  n级标题&lt;/p&gt;
&lt;h1 id=&quot;标题1&quot;&gt;&lt;a href=&quot;#标题1&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/11/23/hello-world/"/>
    <id>http://example.com/2021/11/23/hello-world/</id>
    <published>2021-11-23T00:27:48.068Z</published>
    <updated>2021-11-23T00:27:48.068Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
