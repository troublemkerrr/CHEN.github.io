<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Claire&#39;s Space</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-09T07:51:59.185Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Claire</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMU15-445（FALL 2022）Project 1</title>
    <link href="http://example.com/2023/05/09/p1/"/>
    <id>http://example.com/2023/05/09/p1/</id>
    <published>2023-05-09T07:58:54.777Z</published>
    <updated>2023-05-09T07:51:59.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMU15-445（FALL-2022）Project-1"><a href="#CMU15-445（FALL-2022）Project-1" class="headerlink" title="CMU15-445（FALL 2022）Project 1"></a>CMU15-445（FALL 2022）Project 1</h1><p>只记录自己在实现过程中遇到的问题，所以写得不够详尽（当然也不会公开完整代码</p><h3 id="可扩展哈希表（extendible-hash-table）："><a href="#可扩展哈希表（extendible-hash-table）：" class="headerlink" title="可扩展哈希表（extendible_hash_table）："></a>可扩展哈希表（extendible_hash_table）：</h3><p>可扩展哈希表由ExtendibleHashTable类实现，成员变量有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_depth_;    <span class="comment">// 全局深度，全局深度=目录id的比特位数</span></span><br><span class="line"><span class="keyword">size_t</span> bucket_size_;  <span class="comment">// 桶的大小：桶最大容纳几个数据</span></span><br><span class="line"><span class="keyword">int</span> num_buckets_;     <span class="comment">// 哈希表中桶的数量</span></span><br><span class="line"><span class="keyword">mutable</span> std::mutex latch_;</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;Bucket&gt;&gt; dir_;  <span class="comment">// 目录：目录在指针中存储桶的地址，每个目录被分配一个id，目录扩张时id可能变化。目录数量=2^全局深度</span></span><br></pre></td></tr></table></figure><p>ExtendibleHashTable类中嵌套定义了Bucket类，即桶。Bucket类的成员变量有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> size_;  <span class="comment">// 桶的大小，就是ExtendibleHashTable中的bucket_size_</span></span><br><span class="line"><span class="keyword">int</span> depth_;    <span class="comment">// 局部深度</span></span><br><span class="line">std::list&lt;std::pair&lt;K, V&gt;&gt; list_; <span class="comment">// 所要存储的数据，是k-v对</span></span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2023/05/07/lGqIm7eC3p9LoAM.jpg" alt="可扩展哈希表图示" style="zoom: 33%;" /><p>对于查找/插入/删除操作，都会先映射到目录，再映射到桶。桶的数量是动态的，当桶中的元素超过bucket_size_时，桶会分裂成两个部分。当溢出桶的局部深度等于全局深度时，将发生目录扩容（2倍。</p><p><strong>初始时</strong>哈希表的global_depth_=0，num_buckets_=1，即有一个空桶。桶最初的depth_=0。</p><p>项目提供了IndexOf()方法，用于根据key得到目录id：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">auto</span> ExtendibleHashTable&lt;K, V&gt;::<span class="built_in">IndexOf</span>(<span class="keyword">const</span> K &amp;key) -&gt; <span class="keyword">size_t</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; global_depth_) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> std::hash&lt;K&gt;()(key) &amp; mask; <span class="comment">// key哈希后，末尾保留global_depth_比特位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">size_t</span> index = <span class="built_in">IndexOf</span>(key);</span><br><span class="line">std::shared_ptr&lt;Bucket&gt; bucket_ptr = dir_[index]; <span class="comment">// 拿到指向桶的指针</span></span><br></pre></td></tr></table></figure><p>现详述<strong>插入数据</strong>的过程：</p><p>先通过IndexOf()方法确定要把数据插入哪一个桶中，拿到这个桶。看list_.size()==size_是否为真来判断桶是否满，如果满了就需要先进行桶分裂再插入（但也有例外：如果桶里已经有这个key只需更新其value），否则直接插入数据。注意桶分裂可能发生多次（因为可能拆分桶时，所有数据流向了同一个桶），所以需要用while判断桶是否满了，而非使用if。在桶已满的前提下，如果该桶的局部深度等于全局深度，则需要进行目录扩容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录扩容</span></span><br><span class="line">global_depth_++;</span><br><span class="line"><span class="keyword">size_t</span> len = dir_.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  <span class="comment">// 为扩张的新目录分发桶</span></span><br><span class="line">dir_.<span class="built_in">emplace_back</span>(dir_[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现目录扩容后哈希表会变成这样：</p><img src="https://s2.loli.net/2023/05/07/fSogk6amwZGnxRu.jpg" alt="会有多个目录指针指向同一个桶" style="zoom:25%;" /><p>要把扩容的点指向共同的桶，比如01扩容到三位时变成0<strong>01</strong>和1<strong>01</strong>，两个目录需要同时指向原01的桶，因为在没有分裂之前，旧数据哈希后指向。</p><p>然后将这个待分裂桶的局部深度+1，拆分桶并重新分发目录指针和k-v对。别忘了拆分完后将桶的数量+1。拆分桶的实现细节如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; bucket_ptr-&gt;<span class="built_in">GetDepth</span>(); <span class="comment">// 此时局部深度还未+1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp;it : list) &#123;  <span class="comment">// list是待分裂桶的list_</span></span><br><span class="line">    <span class="keyword">size_t</span> hash_key = std::hash&lt;K&gt;()(it.first);</span><br><span class="line">    <span class="keyword">if</span> ((hash_key &amp; mask) != <span class="number">0U</span>) &#123;  <span class="comment">// 低位相同，只需要判断高位是0还是1</span></span><br><span class="line">    new_bucket0-&gt;<span class="built_in">Insert</span>(it.first, it.second); <span class="comment">// new_bucket0和new_bucket1会成为拆分后的两个桶的指针</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    new_bucket1-&gt;<span class="built_in">Insert</span>(it.first, it.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; dir_.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历目录，找出原桶指针的位置，用new_bucket0和new_bucket1代替</span></span><br><span class="line">    <span class="keyword">if</span> (dir_[i] == bucket_ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; mask) != <span class="number">0U</span>) &#123;  <span class="comment">// 判断高位是0还是1</span></span><br><span class="line">          dir_[i] = new_bucket0;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dir_[i] = new_bucket1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里画出一种可能的情况：</p><img src="https://s2.loli.net/2023/05/08/PO7pNGsButDwRHS.jpg" alt="此处mask=100（二进制" style="zoom:33%;" /><p>根据桶的局部深度得到mask，再用mask和数据的哈希值进行&amp;操作区分高位，从而把桶中数据分成两份，类似的，用mask和目录id相与，将新桶和目录匹配。</p><p>实际上哈希表的根本原理就是把数据哈希，用这个哈希值来将数据分类。最开始数据量少的时候不用分类，都放在一个桶里；然后数据多一些了，就看数据对应哈希值的最低位是0还是1，将数据分成两份即可；数据更多，就再看哈希值的第二低位……以此类推，逐渐细分数据，保证每个桶都没有溢出就好。</p><p><strong>并发控制</strong>就用一把大锁实现。在ExtendibleHashTable类中定义成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> std::mutex latch_;</span><br></pre></td></tr></table></figure><p>然后ExtendibleHashTable类成员函数开头上锁即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="LRU-K-淘汰策略"><a href="#LRU-K-淘汰策略" class="headerlink" title="LRU-K 淘汰策略"></a>LRU-K 淘汰策略</h3><p>不满k次FIFO，满k次LRU。优先从历史队列中淘汰。</p><img src="https://s2.loli.net/2023/05/08/WuJRm25OBZhoilr.png" style="zoom: 50%;" /><p>LRUKReplacer类中成员变量有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[[maybe_unused]] <span class="keyword">size_t</span> current_timestamp_&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> curr_size_&#123;<span class="number">0</span>&#125;; <span class="comment">// LRUKReplacer的大小，LRUKReplacer中可驱逐的缓存帧的数量，Size()方法返回这个</span></span><br><span class="line"><span class="keyword">size_t</span> replacer_size_; <span class="comment">// LRUKReplacer最多缓存多少帧</span></span><br><span class="line"><span class="keyword">size_t</span> k_;</span><br><span class="line">std::mutex latch_;</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;<span class="keyword">frame_id_t</span>, <span class="keyword">bool</span>&gt; is_evictable_; <span class="comment">// 标记是否可驱逐</span></span><br><span class="line"><span class="comment">// 不满k次，放在历史队列中</span></span><br><span class="line">std::list&lt;<span class="keyword">frame_id_t</span>&gt; history_frames_; <span class="comment">// 历史队列</span></span><br><span class="line">std::unordered_map&lt;<span class="keyword">frame_id_t</span>, std::list&lt;<span class="keyword">frame_id_t</span>&gt;::iterator&gt; history_pos_; <span class="comment">// 用于记录帧在队列中的位置，便于删除操作</span></span><br><span class="line">std::unordered_map&lt;<span class="keyword">frame_id_t</span>, <span class="keyword">size_t</span>&gt; history_times_; <span class="comment">// 记录访问次数</span></span><br><span class="line"><span class="comment">// 满k次，放在缓存队列中</span></span><br><span class="line">std::list&lt;<span class="keyword">frame_id_t</span>&gt; cache_frames_; <span class="comment">// 缓存队列</span></span><br><span class="line">std::unordered_map&lt;<span class="keyword">frame_id_t</span>, std::list&lt;<span class="keyword">frame_id_t</span>&gt;::iterator&gt; cache_pos_;</span><br></pre></td></tr></table></figure><p>要实现的方法：</p><ul><li><p>Evict(frame_id_t*)，驱逐一帧</p><p>驱逐后要标记为不可驱逐，从队列（当然也包括位置记录的map、访问次数记录的map）中删除，curr_size_–</p></li><li><p>RecordAccess(frame_id_t)，记录访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(frame_id &gt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(replacer_size_))&#123;  <span class="comment">// 注意类型转换</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果第一次访问：注意将帧标记为不可驱逐。然后把帧加到历史队列末尾，同时更新history_pos_：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history_pos_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(frame_id, --history_frames_.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure></li><li><p>SetEvictable(frame_id_t, bool set_evictable)，控制帧是否可驱逐，以及LRUKReplacer的大小</p><p>如果在is_evictable_里面没有记录或者set_evictable和is_evictable_里面的记录一致，就不管。否则将is_evictable_中的记录更新。再看该帧是否存在于LRUKReplacer中，若存在，再更改curr_size_的大小</p></li><li><p>Remove(frame_id_t)，清除访问记录</p><p>和Evict类似，只不过是指定了驱逐的帧。如果在is_evictable_里面没有记录，或是记录为false，或是不存在于LRUKReplacer中，直接返回。否则删除，并把is_evictable_中的记录置为false，curr_size_–</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history_frames_.<span class="built_in">erase</span>(history_pos_[frame_id]); <span class="comment">// 删除时根据history_pos_中的记录来删</span></span><br></pre></td></tr></table></figure></li><li><p>Size()</p><p>返回curr_size_</p></li></ul><p>个人觉得难点在于对curr_size_的把控。</p><p>并发控制还是一把大锁，和可扩展哈希一样。</p><hr><h3 id="缓冲池管理器（BufferPoolManagerInstance）"><a href="#缓冲池管理器（BufferPoolManagerInstance）" class="headerlink" title="缓冲池管理器（BufferPoolManagerInstance）"></a>缓冲池管理器（BufferPoolManagerInstance）</h3><p>一些基本概念：</p><ul><li><p>page_id 与 frame_id</p><p>磁盘被划分为若干块（页），每个块都用唯一的 page_id 来标识，disk_manager 就是根据 page_id 来读取和写入磁盘页。</p><p>磁盘页加载到内存，内存中也需要有相应的内存页（人为划分的内存页，也称为帧），BufferPoolManager 管理的正是这些内存块，和磁盘类似，内存页也有相应的标识 frame_id 来唯一标记这些内存页。</p></li><li><p>Pin 与 Unpin</p><p>Pin：把 frame_id 对应页面剔除 lru_list， 表示该页面被线程占用，不可以被置换出去。</p><p>Unpin：把 frame_id 对应的页面加入 lru_list，表示该页面可以被加入lru_replacer。</p></li><li><p>Page</p><p>系统中的所有内存页面都由 Page 对象表示。Page 对象主要由 metadata 和 data_[] 两部分构成，metedata 是一些元数据信息，如 page_id_, pin_count_、is_dirty_等，而 data_字符数组则是存储磁盘页的具体数据内容。 Page 对象是可以被重用的，即每个Page 对象都可以装入不同的磁盘页面。</p><p>pin_count_：用于记录当前内存页被占用的线程数量。NewPgImp 后 pin_count_ = 1, FetchPgImp 后pin_count_++, UnpinPg 后 pin_count_–-, pin_count_ 为 0 后可以逐出 LRUReplacer。</p><p>is_dirty_：用于记录当前内存页数据是否被修改（相对于磁盘数据）。</p></li></ul><p>再来看BufferPoolManagerInstance类的成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> pool_size_; <span class="comment">// 缓冲池能够管理的最大内存页数量，实际上就是pages_数组的大小</span></span><br><span class="line">std::atomic&lt;<span class="keyword">page_id_t</span>&gt; next_page_id_ = <span class="number">0</span>; <span class="comment">// 下一个将被分配的page_id，在创建新页时使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> bucket_size_ = <span class="number">4</span>; <span class="comment">// 可扩展哈希表中桶的大小</span></span><br><span class="line"></span><br><span class="line">Page *pages_; <span class="comment">// Page类型对象的数组，可将数组索引视为该页对应的frame_id</span></span><br><span class="line">DiskManager *disk_manager_ __attribute__((__unused__)); <span class="comment">// 磁盘管理器，用于执行与磁盘相关的底层操作，常用的有写入数据到磁盘WritePage和从磁盘读取数据ReadPage</span></span><br><span class="line">LogManager *log_manager_ __attribute__((__unused__));</span><br><span class="line">ExtendibleHashTable&lt;<span class="keyword">page_id_t</span>, <span class="keyword">frame_id_t</span>&gt; *page_table_; <span class="comment">// page_table_，用于页面映射</span></span><br><span class="line">LRUKReplacer *replacer_; <span class="comment">// replacer_,页面置换策略</span></span><br><span class="line">std::list&lt;<span class="keyword">frame_id_t</span>&gt; free_list_; <span class="comment">// 空闲内存页链表，刚实例化BPM时，所有的页面都应该加入free_list_, 此时LRUReplacer为空，没有可以置换的页面</span></span><br><span class="line">std::mutex latch_;</span><br></pre></td></tr></table></figure><p>要实现的方法：</p><ul><li><p>NewPgImp(page_id)：从磁盘创建一个新的物理页，然后在内存 BufferPool 找到一个位置放入。因为新申请的物理页没有有效的 data，所以 NewPgImp 不需要 ReadPage 操作，只需要完成元数据更新，ResetMemory 即可。优先使用free_list_中的空间，否则从replacer_中驱逐一页，腾出空间。放入 BufferPool 需要：将页面映射关系加入page_table_、放入replacer_、更新pages_数组中对应页面的信息。</p><p>注意replacer_中驱逐一页时需要先判断该页是否脏，若脏要写回磁盘。</p></li><li><p>FetchPgImp(page_id)：优先从 BufferPool 取 page_id 对应页面，如果不存在，则从磁盘调入（还是优先使用free_list_中的空间，否则从replacer_中驱逐一页，腾出空间），会把数据一起写入 BufferPool 内存页。</p></li><li><p>UnpinPgImp(page_id, is_dirty)：注意仅当 is_dirty 为真时才考虑改变 is_dirty_ 属性。</p></li><li><p>FlushPgImp(page_id) 与 FlushAllPagesImpl()：将页写回磁盘。</p></li><li><p>DeletePgImp(page_id)：如果 pin_count&gt;0，不能删除。注意将page_table_、replacer_、pages_数组中的有关信息一并清除，并把对应的frame_id 放回free_list_。</p></li></ul><p>一开始没有理解 BufferPool 的架构，苦恼了好一阵子。理解之后实现时多注意细节就好了。</p><p>并发控制：一把大锁。</p><hr><h3 id="🎈"><a href="#🎈" class="headerlink" title="🎈"></a>🎈</h3><img src="https://s2.loli.net/2023/05/09/KOoi1dn8PmGsTxk.png" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CMU15-445（FALL-2022）Project-1&quot;&gt;&lt;a href=&quot;#CMU15-445（FALL-2022）Project-1&quot; class=&quot;headerlink&quot; title=&quot;CMU15-445（FALL 2022）Project 1&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMU15-445（FALL 2022）Project 0</title>
    <link href="http://example.com/2023/05/05/p0/"/>
    <id>http://example.com/2023/05/05/p0/</id>
    <published>2023-05-05T01:41:37.103Z</published>
    <updated>2023-05-05T01:52:29.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMU15-445（FALL-2022）Project-0"><a href="#CMU15-445（FALL-2022）Project-0" class="headerlink" title="CMU15-445（FALL 2022）Project 0"></a>CMU15-445（FALL 2022）Project 0</h1><p>只记录自己在实现过程中遇到的问题，所以写得不够详尽（当然也不会公开完整代码</p><p>用时两个月紧赶慢赶地终于做完了p3。本来是打算等全部做完再开始写博客的，但是我突然有了一种很累想歇歇的感觉，所以干脆先写写博客、解决下之前遗留的问题，休息一阵子再研究p4吧。</p><h3 id="开始的开始——环境搭建："><a href="#开始的开始——环境搭建：" class="headerlink" title="开始的开始——环境搭建："></a>开始的开始——环境搭建：</h3><p>我的环境：Linux虚拟机（Ubuntu20.04.4）+ vscode远程连接，个人觉得挺舒服的</p><p>注意2022秋的代码仓库在这里：<a href="https://github.com/cmu-db/bustub/releases/tag/v20221128-2022fall">https://github.com/cmu-db/bustub/releases/tag/v20221128-2022fall</a> ，不要不小心把最新版本的拉下来</p><hr><h3 id="实现一颗字典树"><a href="#实现一颗字典树" class="headerlink" title="实现一颗字典树"></a>实现一颗字典树</h3><img src="https://s2.loli.net/2023/05/05/GZ4quAjsOytIQnE.jpg" alt="字典树图示" style="zoom: 25%;" /><p>图示是一颗字典树，其中共有5对键值对：(“ab”,1)，(“ac”,2)，(“bc”,3)，(“bcd”,4)，(“bef”,5)。因为不允许插入重复key，所以实际上一颗字典树里有几个TrieNodeWithValue就有几个key。</p><p><strong>如何遍历字典树？</strong>插入、删除和查找操作都离不开遍历。注意Trie类中的成员，根节点root_用一个unique_ptr来表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;TrieNode&gt; root_;</span><br></pre></td></tr></table></figure><p>遍历都从根节点开始。定义一个指向root_的unique_ptr，命名为cur，此后就利用cur来遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;TrieNode&gt; *cur = &amp;root_;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往下遍历一步，走到key_char_=key_char的节点上</span></span><br><span class="line">std::unique_ptr&lt;TrieNode&gt; *temp = (*cur)-&gt;<span class="built_in">GetChildNode</span>(key_char);</span><br><span class="line">cur = temp;</span><br></pre></td></tr></table></figure><p><strong>删除key时</strong>我也遇到一些小问题。就上图而言，如果想要删除(“bc”,3)，那么把(c-&gt;3)这个TrieNodeWithValue转换为TrieNode即可。如果想要删除(“bef”,5)，就需要把从(e)开始 包括自己及以下的所有节点用递归的方式删除。</p><p>如何判断删除时应该转换还是递归删除？看待删除key的下面还有没有路。比如”bc”下面还有(d-&gt;4)，有路，转换；”bef”下面没有路，递归删除。</p><p>如何递归删除？先判断起始节点begin_node，起始节点定义为遍历过程中遇到的倒数第二个TrieNodeWithValue，如果不存在就为root_。注意起始节点并不代表就要从这里一路删到底，只能说明在此之上没有需要删除的节点，从这里开始处理不会漏删。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Destory</span>(begin_node, key, i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归删除整棵树</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Destory</span><span class="params">(std::unique_ptr&lt;TrieNode&gt; *cur, <span class="keyword">const</span> std::string &amp;key, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="keyword">char</span>&gt;::size_type pos = i;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; key.<span class="built_in">size</span>() &amp;&amp; (*cur)-&gt;<span class="built_in">HasChild</span>(key[i])) &#123;</span><br><span class="line">      std::unique_ptr&lt;TrieNode&gt; *temp = (*cur)-&gt;<span class="built_in">GetChildNode</span>(key[i]);</span><br><span class="line">      flag = <span class="built_in">Destory</span>(temp, key, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      (*cur)-&gt;<span class="built_in">RemoveChildNode</span>(key[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*cur)-&gt;<span class="built_in">HasChildren</span>();  <span class="comment">// 如果有分支，就不再删除上面的部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>在Trie类中定义读写锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReaderWriterLatch latch_;</span><br></pre></td></tr></table></figure><p>对于插入和删除，上写锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">latch_.<span class="built_in">WLock</span>(); <span class="comment">// 函数开始时写这句</span></span><br><span class="line">latch_.<span class="built_in">WUnlock</span>(); <span class="comment">// 函数return前写这句</span></span><br></pre></td></tr></table></figure><p>对于查找只需要上读锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">latch_.<span class="built_in">RLock</span>();</span><br><span class="line">latch_.<span class="built_in">RUnlock</span>();</span><br></pre></td></tr></table></figure><hr><h3 id="记一些语法错误"><a href="#记一些语法错误" class="headerlink" title="记一些语法错误"></a>记一些语法错误</h3><p>我对c++的移动语义太不熟悉了，开始连编译都难过😢。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TrieNode</span>(TrieNode &amp;&amp;other_trie_node) <span class="keyword">noexcept</span> &#123; <span class="comment">// noexcept:告诉编译器，函数中不会发生异常</span></span><br><span class="line">    is_end_=other_trie_node.is_end_;</span><br><span class="line">    key_char_=other_trie_node.key_char_;</span><br><span class="line">    <span class="comment">// children_=other_trie_node.children_;❌ children_的类型嵌套了std::unique_ptr&lt;T&gt;，需要使用移动语义</span></span><br><span class="line">    children_=std::<span class="built_in">move</span>(other_trie_node.children_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert时到达最后一个节点，要把TrieNode转换成TrieNodeWithValue</span></span><br><span class="line"><span class="keyword">auto</span> new_node_ptr = <span class="keyword">new</span> TrieNodeWithValue&lt;T&gt;(std::<span class="built_in">move</span>(**cur), value);</span><br><span class="line">(*cur).<span class="built_in">reset</span>(new_node_ptr); <span class="comment">// 释放cur指向的资源对象，同时指向新的对象，用reset()</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TrieNodeWithValue(TrieNode &amp;&amp;trieNode, T value):TrieNode(trieNode) &#123;❌需要使用std::forward&lt;TrieNode&gt;转发右值引用</span></span><br><span class="line"><span class="built_in">TrieNodeWithValue</span>(TrieNode &amp;&amp;trieNode, T value):<span class="built_in">TrieNode</span>(std::forward&lt;TrieNode&gt;(trieNode)) &#123;</span><br><span class="line">    <span class="built_in">SetEndNode</span>(<span class="literal">true</span>);</span><br><span class="line">    value_=value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrieNode *last_node = (*cur).<span class="built_in">get</span>();  <span class="comment">// get()方法返回裸指针,不能用release() </span></span><br></pre></td></tr></table></figure><hr><h3 id="🎉"><a href="#🎉" class="headerlink" title="🎉"></a>🎉</h3><img src="https://s2.loli.net/2023/05/05/NIc3LoFU2A54vtX.png" alt="全部通过！" style="zoom: 50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CMU15-445（FALL-2022）Project-0&quot;&gt;&lt;a href=&quot;#CMU15-445（FALL-2022）Project-0&quot; class=&quot;headerlink&quot; title=&quot;CMU15-445（FALL 2022）Project 0&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Claire&#39;s Art Show</title>
    <link href="http://example.com/2022/02/10/art/"/>
    <id>http://example.com/2022/02/10/art/</id>
    <published>2022-02-10T09:02:30.901Z</published>
    <updated>2023-05-09T07:58:51.007Z</updated>
    
    <content type="html"><![CDATA[<p>2021/12/13</p><p><img src="https://s2.loli.net/2022/01/21/EDl5TA94tbHnOvd.jpg"></p><p>2022/01/28</p><p><img src="https://s2.loli.net/2022/02/10/wRh6UrIaTQ4ZFzt.jpg"></p><p>2022/02/07</p><p><img src="https://s2.loli.net/2022/02/10/D1fdQh2sCKjWIO7.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2021/12/13&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/21/EDl5TA94tbHnOvd.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2022/01/28&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>learn to use typora</title>
    <link href="http://example.com/2022/01/17/learn%20to%20use%20typora/"/>
    <id>http://example.com/2022/01/17/learn%20to%20use%20typora/</id>
    <published>2022-01-17T11:55:34.810Z</published>
    <updated>2023-05-04T09:31:48.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><p>Ctrl+n :  n级标题</p><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h5 id="标题5"><a href="#标题5" class="headerlink" title="标题5"></a>标题5</h5><h6 id="标题6"><a href="#标题6" class="headerlink" title="标题6"></a>标题6</h6><p>正文</p><h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h3><p>引用 :  &gt; + 空格</p><p>退出引用 :  Shift + Tab</p><p>角标 :  </p><p>方括号里括^和数字</p><p>角标<a href="%E5%87%BA%E8%87%AA%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7">^1</a></p><blockquote><p>引用</p></blockquote><h3 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h3><p>无序列表 :  Ctrl + Shift + ]</p><p>子列表 :  Tab</p><p>回退 :  Shift + Tab</p><ul><li>列表</li><li>列表<ul><li>子列表<ul><li>子列表again</li></ul></li><li>回退到上一个子列表</li></ul></li><li>再回退</li></ul><p>有序列表 :  Ctrl + Shift +[</p><ol><li>列表</li><li>列表<ol><li>子列表</li></ol></li></ol><h3 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h3><p>[链接名称] + (地址)</p><p><a href="www.baidu.com">百度</a></p><h3 id="5-图像"><a href="#5-图像" class="headerlink" title="5.图像"></a>5.图像</h3><p><img src="https://s2.loli.net/2022/01/17/xb8MypS2BOLKavU.jpg"></p><h3 id="6-划重点"><a href="#6-划重点" class="headerlink" title="6.划重点"></a>6.划重点</h3><p>高亮 :   <img src="https://s2.loli.net/2022/01/17/IiqoHKBjLxzGdwb.png"></p><p>==高亮==</p><p>加粗 ：Ctrl + B</p><p><strong>加粗</strong></p><p>两个*中间夹斜体</p><p><em>斜体</em></p><h3 id="7-表格"><a href="#7-表格" class="headerlink" title="7.表格"></a>7.表格</h3><p>插入表格 ：Ctrl + T</p><table><thead><tr><th>chen</th><th></th><th></th></tr></thead><tbody><tr><td>zhang</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.代码块"></a>8.代码块</h3><p>输入3个*并按回车</p><hr><p>int c=1;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-标题&quot;&gt;&lt;a href=&quot;#1-标题&quot; class=&quot;headerlink&quot; title=&quot;1.标题&quot;&gt;&lt;/a&gt;1.标题&lt;/h3&gt;&lt;p&gt;Ctrl+n :  n级标题&lt;/p&gt;
&lt;h1 id=&quot;标题1&quot;&gt;&lt;a href=&quot;#标题1&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/11/23/hello-world/"/>
    <id>http://example.com/2021/11/23/hello-world/</id>
    <published>2021-11-23T00:27:48.068Z</published>
    <updated>2021-11-23T00:27:48.068Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
