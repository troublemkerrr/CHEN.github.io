<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Claire&#39;s Space</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-05T01:52:29.251Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Claire</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMU15-445（FALL 2022）Project 0</title>
    <link href="http://example.com/2023/05/05/p0/"/>
    <id>http://example.com/2023/05/05/p0/</id>
    <published>2023-05-05T01:41:37.103Z</published>
    <updated>2023-05-05T01:52:29.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMU15-445（FALL-2022）Project-0"><a href="#CMU15-445（FALL-2022）Project-0" class="headerlink" title="CMU15-445（FALL 2022）Project 0"></a>CMU15-445（FALL 2022）Project 0</h1><p>只记录自己在实现过程中遇到的问题，所以写得不够详尽（当然也不会公开完整代码</p><p>用时两个月紧赶慢赶地终于做完了p3。本来是打算等全部做完再开始写博客的，但是我突然有了一种很累想歇歇的感觉，所以干脆先写写博客、解决下之前遗留的问题，休息一阵子再研究p4吧。</p><h3 id="开始的开始——环境搭建："><a href="#开始的开始——环境搭建：" class="headerlink" title="开始的开始——环境搭建："></a>开始的开始——环境搭建：</h3><p>我的环境：Linux虚拟机（Ubuntu20.04.4）+ vscode远程连接，个人觉得挺舒服的</p><p>注意2022秋的代码仓库在这里：<a href="https://github.com/cmu-db/bustub/releases/tag/v20221128-2022fall">https://github.com/cmu-db/bustub/releases/tag/v20221128-2022fall</a> ，不要不小心把最新版本的拉下来</p><hr><h3 id="实现一颗字典树"><a href="#实现一颗字典树" class="headerlink" title="实现一颗字典树"></a>实现一颗字典树</h3><img src="https://s2.loli.net/2023/05/05/GZ4quAjsOytIQnE.jpg" alt="字典树图示" style="zoom: 25%;" /><p>图示是一颗字典树，其中共有5对键值对：(“ab”,1)，(“ac”,2)，(“bc”,3)，(“bcd”,4)，(“bef”,5)。因为不允许插入重复key，所以实际上一颗字典树里有几个TrieNodeWithValue就有几个key。</p><p><strong>如何遍历字典树？</strong>插入、删除和查找操作都离不开遍历。注意Trie类中的成员，根节点root_用一个unique_ptr来表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;TrieNode&gt; root_;</span><br></pre></td></tr></table></figure><p>遍历都从根节点开始。定义一个指向root_的unique_ptr，命名为cur，此后就利用cur来遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;TrieNode&gt; *cur = &amp;root_;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往下遍历一步，走到key_char_=key_char的节点上</span></span><br><span class="line">std::unique_ptr&lt;TrieNode&gt; *temp = (*cur)-&gt;<span class="built_in">GetChildNode</span>(key_char);</span><br><span class="line">cur = temp;</span><br></pre></td></tr></table></figure><p><strong>删除key时</strong>我也遇到一些小问题。就上图而言，如果想要删除(“bc”,3)，那么把(c-&gt;3)这个TrieNodeWithValue转换为TrieNode即可。如果想要删除(“bef”,5)，就需要把从(e)开始 包括自己及以下的所有节点用递归的方式删除。</p><p>如何判断删除时应该转换还是递归删除？看待删除key的下面还有没有路。比如”bc”下面还有(d-&gt;4)，有路，转换；”bef”下面没有路，递归删除。</p><p>如何递归删除？先判断起始节点begin_node，起始节点定义为遍历过程中遇到的倒数第二个TrieNodeWithValue，如果不存在就为root_。注意起始节点并不代表就要从这里一路删到底，只能说明在此之上没有需要删除的节点，从这里开始处理不会漏删。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Destory</span>(begin_node, key, i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归删除整棵树</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Destory</span><span class="params">(std::unique_ptr&lt;TrieNode&gt; *cur, <span class="keyword">const</span> std::string &amp;key, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::__cxx11::basic_string&lt;<span class="keyword">char</span>&gt;::size_type pos = i;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; key.<span class="built_in">size</span>() &amp;&amp; (*cur)-&gt;<span class="built_in">HasChild</span>(key[i])) &#123;</span><br><span class="line">      std::unique_ptr&lt;TrieNode&gt; *temp = (*cur)-&gt;<span class="built_in">GetChildNode</span>(key[i]);</span><br><span class="line">      flag = <span class="built_in">Destory</span>(temp, key, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      (*cur)-&gt;<span class="built_in">RemoveChildNode</span>(key[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*cur)-&gt;<span class="built_in">HasChildren</span>();  <span class="comment">// 如果有分支，就不再删除上面的部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>在Trie类中定义读写锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReaderWriterLatch latch_;</span><br></pre></td></tr></table></figure><p>对于插入和删除，上写锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">latch_.<span class="built_in">WLock</span>(); <span class="comment">// 函数开始时写这句</span></span><br><span class="line">latch_.<span class="built_in">WUnlock</span>(); <span class="comment">// 函数return前写这句</span></span><br></pre></td></tr></table></figure><p>对于查找只需要上读锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">latch_.<span class="built_in">RLock</span>();</span><br><span class="line">latch_.<span class="built_in">RUnlock</span>();</span><br></pre></td></tr></table></figure><hr><h3 id="记一些语法错误"><a href="#记一些语法错误" class="headerlink" title="记一些语法错误"></a>记一些语法错误</h3><p>我对c++的移动语义太不熟悉了，开始连编译都难过😢。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TrieNode</span>(TrieNode &amp;&amp;other_trie_node) <span class="keyword">noexcept</span> &#123; <span class="comment">// noexcept:告诉编译器，函数中不会发生异常</span></span><br><span class="line">    is_end_=other_trie_node.is_end_;</span><br><span class="line">    key_char_=other_trie_node.key_char_;</span><br><span class="line">    <span class="comment">// children_=other_trie_node.children_;❌ children_的类型嵌套了std::unique_ptr&lt;T&gt;，需要使用移动语义</span></span><br><span class="line">    children_=std::<span class="built_in">move</span>(other_trie_node.children_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert时到达最后一个节点，要把TrieNode转换成TrieNodeWithValue</span></span><br><span class="line"><span class="keyword">auto</span> new_node_ptr = <span class="keyword">new</span> TrieNodeWithValue&lt;T&gt;(std::<span class="built_in">move</span>(**cur), value);</span><br><span class="line">(*cur).<span class="built_in">reset</span>(new_node_ptr); <span class="comment">// 释放cur指向的资源对象，同时指向新的对象，用reset()</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TrieNodeWithValue(TrieNode &amp;&amp;trieNode, T value):TrieNode(trieNode) &#123;❌需要使用std::forward&lt;TrieNode&gt;转发右值引用</span></span><br><span class="line"><span class="built_in">TrieNodeWithValue</span>(TrieNode &amp;&amp;trieNode, T value):<span class="built_in">TrieNode</span>(std::forward&lt;TrieNode&gt;(trieNode)) &#123;</span><br><span class="line">    <span class="built_in">SetEndNode</span>(<span class="literal">true</span>);</span><br><span class="line">    value_=value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrieNode *last_node = (*cur).<span class="built_in">get</span>();  <span class="comment">// get()方法返回裸指针,不能用release() </span></span><br></pre></td></tr></table></figure><hr><h3 id="🎉"><a href="#🎉" class="headerlink" title="🎉"></a>🎉</h3><img src="https://s2.loli.net/2023/05/05/NIc3LoFU2A54vtX.png" alt="全部通过！" style="zoom: 50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CMU15-445（FALL-2022）Project-0&quot;&gt;&lt;a href=&quot;#CMU15-445（FALL-2022）Project-0&quot; class=&quot;headerlink&quot; title=&quot;CMU15-445（FALL 2022）Project 0&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Claire&#39;s Art Show</title>
    <link href="http://example.com/2022/02/10/art/"/>
    <id>http://example.com/2022/02/10/art/</id>
    <published>2022-02-10T09:02:30.901Z</published>
    <updated>2023-05-05T01:41:15.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sticky-1"><a href="#sticky-1" class="headerlink" title="sticky: 1"></a>sticky: 1</h2><p>2021/12/13</p><p><img src="https://s2.loli.net/2022/01/21/EDl5TA94tbHnOvd.jpg"></p><p>2022/01/28</p><p><img src="https://s2.loli.net/2022/02/10/wRh6UrIaTQ4ZFzt.jpg"></p><p>2022/02/07</p><p><img src="https://s2.loli.net/2022/02/10/D1fdQh2sCKjWIO7.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;sticky-1&quot;&gt;&lt;a href=&quot;#sticky-1&quot; class=&quot;headerlink&quot; title=&quot;sticky: 1&quot;&gt;&lt;/a&gt;sticky: 1&lt;/h2&gt;&lt;p&gt;2021/12/13&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>learn to use typora</title>
    <link href="http://example.com/2022/01/17/learn%20to%20use%20typora/"/>
    <id>http://example.com/2022/01/17/learn%20to%20use%20typora/</id>
    <published>2022-01-17T11:55:34.810Z</published>
    <updated>2023-05-04T09:31:48.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><p>Ctrl+n :  n级标题</p><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h5 id="标题5"><a href="#标题5" class="headerlink" title="标题5"></a>标题5</h5><h6 id="标题6"><a href="#标题6" class="headerlink" title="标题6"></a>标题6</h6><p>正文</p><h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h3><p>引用 :  &gt; + 空格</p><p>退出引用 :  Shift + Tab</p><p>角标 :  </p><p>方括号里括^和数字</p><p>角标<a href="%E5%87%BA%E8%87%AA%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7">^1</a></p><blockquote><p>引用</p></blockquote><h3 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h3><p>无序列表 :  Ctrl + Shift + ]</p><p>子列表 :  Tab</p><p>回退 :  Shift + Tab</p><ul><li>列表</li><li>列表<ul><li>子列表<ul><li>子列表again</li></ul></li><li>回退到上一个子列表</li></ul></li><li>再回退</li></ul><p>有序列表 :  Ctrl + Shift +[</p><ol><li>列表</li><li>列表<ol><li>子列表</li></ol></li></ol><h3 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h3><p>[链接名称] + (地址)</p><p><a href="www.baidu.com">百度</a></p><h3 id="5-图像"><a href="#5-图像" class="headerlink" title="5.图像"></a>5.图像</h3><p><img src="https://s2.loli.net/2022/01/17/xb8MypS2BOLKavU.jpg"></p><h3 id="6-划重点"><a href="#6-划重点" class="headerlink" title="6.划重点"></a>6.划重点</h3><p>高亮 :   <img src="https://s2.loli.net/2022/01/17/IiqoHKBjLxzGdwb.png"></p><p>==高亮==</p><p>加粗 ：Ctrl + B</p><p><strong>加粗</strong></p><p>两个*中间夹斜体</p><p><em>斜体</em></p><h3 id="7-表格"><a href="#7-表格" class="headerlink" title="7.表格"></a>7.表格</h3><p>插入表格 ：Ctrl + T</p><table><thead><tr><th>chen</th><th></th><th></th></tr></thead><tbody><tr><td>zhang</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.代码块"></a>8.代码块</h3><p>输入3个*并按回车</p><hr><p>int c=1;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-标题&quot;&gt;&lt;a href=&quot;#1-标题&quot; class=&quot;headerlink&quot; title=&quot;1.标题&quot;&gt;&lt;/a&gt;1.标题&lt;/h3&gt;&lt;p&gt;Ctrl+n :  n级标题&lt;/p&gt;
&lt;h1 id=&quot;标题1&quot;&gt;&lt;a href=&quot;#标题1&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/11/23/hello-world/"/>
    <id>http://example.com/2021/11/23/hello-world/</id>
    <published>2021-11-23T00:27:48.068Z</published>
    <updated>2021-11-23T00:27:48.068Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
